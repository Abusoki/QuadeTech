<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Life Tracker</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f2f5;
            color: #333;
        }
        #app-container {
            width: 100%;
            max-width: 450px;
            background-color: white;
            padding: 25px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-radius: 12px;
        }
        
        /* --- General Styles --- */
        input {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-sizing: border-box;
        }
        button {
            cursor: pointer;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            transition: transform 0.1s, opacity 0.2s;
        }
        button:active {
            transform: scale(0.96);
        }
        .btn-primary {
            width: 100%;
            padding: 12px;
            background-color: #2ecc71;
            color: white;
            font-size: 1.1em;
            margin-top: 10px;
        }
        .btn-danger {
            width: 100%;
            padding: 12px;
            background-color: #e74c3c;
            color: white;
            margin-top: 5px;
        }
        .btn-secondary {
            background-color: #95a5a6;
            color: white;
            padding: 8px;
            margin-left: 5px;
        }
        
        /* --- Game View Styles --- */
        .player-counter {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        .life-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        /* NEW: Editable life input style */
        .life-input {
            font-size: 2.5em;
            font-weight: 800;
            color: #2c3e50;
            width: 100px; /* Wider input for life total */
            padding: 0;
            border: none;
            text-align: left;
            background: none;
            box-sizing: content-box;
            height: 1.5em; /* Match line height */
            line-height: 1.5em;
        }
        
        .life-total { /* Kept for opponents */
            font-size: 2.5em;
            font-weight: 800;
            color: #2c3e50;
        }

        .player-name-display {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 5px;
        }
        .cmd-name {
            font-size: 0.9em;
            color: #7f8c8d;
        }
        .btn-life {
            padding: 8px 12px;
            font-size: 1em;
            background-color: #3498db;
            color: white;
        }
        .btn-damage {
            padding: 4px 8px;
            font-size: 0.9em;
            background-color: #e74c3c;
            color: white;
        }
        .damage-section {
            background-color: #f9f9f9;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
        }
        .damage-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        .control-group {
            display: flex;
            gap: 5px;
        }
        
        /* Editable damage input style */
        .damage-input {
            width: 50px; 
            padding: 4px;
            text-align: center;
            font-weight: bold;
            font-size: 1em;
            margin: 0;
            height: auto;
            border: 1px solid #ccc;
            background-color: white;
        }
        .damage-input.lethal {
            color: red;
            border-color: red;
        }

        /* --- Lobby Features --- */
        #lobby-features button {
            background-color: #2980b9;
            color: white;
            width: 48%;
            padding: 10px;
            margin-bottom: 10px;
        }
        #lobby-features {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 5px;
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 15px;
        }
        #roll-result {
            font-size: 1.5em;
            font-weight: bold;
            color: #2c3e50;
            margin-left: 10px;
        }

        /* --- Chat Styles --- */
        #chat-container {
            margin-top: 20px;
            border-top: 1px solid #ddd;
            padding-top: 15px;
        }
        #chat-log {
            height: 150px;
            overflow-y: auto;
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 6px;
            background-color: #fcfcfc;
            font-size: 0.9em;
        }
        .chat-message {
            margin-bottom: 5px;
            word-wrap: break-word;
        }
        .chat-sender {
            font-weight: bold;
            margin-right: 5px;
        }
        #chat-input-form {
            display: flex;
            gap: 5px;
        }
        #chat-input-form input {
            flex-grow: 1;
            margin: 0;
            padding: 8px;
        }
        #chat-input-form button {
            width: auto;
            padding: 8px 15px;
            background-color: #3498db;
            color: white;
        }
        
        /* --- Modal for Card Search --- */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        #search-results img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            margin-top: 15px;
        }
        
        /* Global delete button style */
        #delete-all-rooms-btn {
            background-color: #c0392b; 
            color: white;
            padding: 10px 15px;
            margin-top: 20px;
            border-radius: 6px;
            font-size: 0.9em;
        }
        
        /* Title Styles */
        .app-title {
            color: #2c3e50;
            margin-bottom: 5px;
            font-size: 2em;
        }
        .app-subtitle {
            color: #7f8c8d;
            font-size: 0.9em;
            margin-bottom: 20px;
            font-style: italic;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
</head>
<body>

    <div id="app-container">
        </div>

    <p id="status-message">Initializing...</p>

    <div id="card-search-modal" class="modal">
        <div class="modal-content">
            <h3>Card Search (Scryfall)</h3>
            <input type="text" id="modal-card-name" placeholder="Enter card name">
            <button id="modal-search-btn" class="btn-primary">Search</button>
            <div id="search-results"></div>
            <button id="modal-close-btn" class="btn-danger">Close</button>
        </div>
    </div>
    
    <script type="module">
        // ----------------------------------------------------------------------
        // 1. CONFIGURATION
        // ----------------------------------------------------------------------
        const USER_FIREBASE_CONFIG = {
            apiKey: "AIzaSyA_mz_fVsph8VHfCEG__9sWg_ZvwYX5_6E", 
            authDomain: "mtg-life-tool.firebaseapp.com",
            projectId: "mtg-life-tool", 
            storageBucket: "mtg-life-tool.appspot.com",
            messagingSenderId: "36730058988",
            appId: "1:36730058988:web:757e2d9620593b4f65022a"
        };
        const SCRYFALL_API = "https://api.scryfall.com/cards/named?exact=";
        const TIMEOUT_MINUTES = 25; 
        const DELETE_ALL_PWD = "DeleteAllRooms"; 
        
        // ----------------------------------------------------------------------
        // 2. IMPORTS
        // ----------------------------------------------------------------------
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, serverTimestamp, arrayUnion, deleteDoc, collection, getDocs, query, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ----------------------------------------------------------------------
        // 3. GLOBALS
        // ----------------------------------------------------------------------
        const app = initializeApp(USER_FIREBASE_CONFIG);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let userId = null;
        let roomId = null;
        let unsubscribe = null;
        const ROOM_COLLECTION = "mtg_rooms";

        // ----------------------------------------------------------------------
        // 4. HELPERS
        // ----------------------------------------------------------------------
        function hashPassword(password) {
            return CryptoJS.SHA256(password).toString(CryptoJS.enc.Hex);
        }

        async function checkAndDeleteIfExpired(id, roomData) {
            const lastActive = roomData.lastActive?.toDate();
            if (lastActive) {
                const elapsed = (new Date() - lastActive) / (1000 * 60);
                if (elapsed > TIMEOUT_MINUTES) {
                    try { await deleteDoc(doc(db, ROOM_COLLECTION, id)); } catch(e){}
                    return true;
                }
            }
            return false;
        }
        
        function getStartingLife() {
            return 40; 
        }

        // ----------------------------------------------------------------------
        // 5. GAME LOGIC & RENDERING
        // ----------------------------------------------------------------------
        
        function renderChat(chatLog, playerName) {
            const chatLogDiv = document.getElementById('chat-log');
            if (!chatLogDiv) return;

            chatLogDiv.innerHTML = '';
            
            const displayLog = chatLog.slice(-20); 

            displayLog.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('chat-message');

                const senderSpan = document.createElement('span');
                senderSpan.classList.add('chat-sender');
                senderSpan.textContent = `${msg.senderName}:`;
                
                if (msg.senderName === playerName) {
                    senderSpan.style.color = '#3498db'; 
                }

                messageDiv.appendChild(senderSpan);
                messageDiv.appendChild(document.createTextNode(msg.message));
                chatLogDiv.appendChild(messageDiv);
            });

            chatLogDiv.scrollTop = chatLogDiv.scrollHeight;
        }

        function renderRoomView(roomData) {
            const appContainer = document.getElementById("app-container");
            const statusMessage = document.getElementById("status-message");

            const currentPlayerName = roomData.players[userId]?.name || 'You';
            statusMessage.innerHTML = `Connected as: <strong>${currentPlayerName}</strong>`;
            
            let html = `
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                    <h2 style="margin:0;">Room: ${roomId}</h2>
                    <div style="display:flex; gap:10px;">
                        <button id="delete-room-btn" class="btn-danger" style="width:auto; padding: 5px 10px;">Delete Room</button>
                        <button id="refresh-btn" class="btn-secondary" style="width:auto; padding: 5px 10px;">â†»</button>
                    </div>
                </div>
            `;
            
            const playerIds = Object.keys(roomData.players);
            playerIds.sort((a, b) => (a === userId ? -1 : b === userId ? 1 : 0));

            html += `<h3 style="margin-top:0;">Players</h3>`;

            playerIds.forEach(playerId => {
                const player = roomData.players[playerId];
                const isMe = playerId === userId;
                
                let lifeControls = '';
                let lifeDisplayHtml = ''; 
                
                if (isMe) {
                    // Current Player: Editable Life Total and Controls
                    lifeDisplayHtml = `
                        <input 
                            type="number" 
                            value="${player.life}" 
                            class="life-input"
                            onchange="updateLifeDirectly(this.value)"
                        >`;
                    
                    lifeControls = `
                        <div class="control-group">
                            <button class="btn-life" data-type="life" data-val="-1">-1</button>
                            <button class="btn-life" data-type="life" data-val="-5">-5</button>
                            <button class="btn-life" data-type="life" data-val="+1">+1</button>
                            <button class="btn-life" data-type="life" data-val="+5">+5</button>
                        </div>
                    `;
                } else {
                    // Opponent: Static Life Total
                    lifeDisplayHtml = `<span class="life-total">${player.life}</span>`;
                }

                let damageRows = '';
                const opponents = playerIds.filter(id => id !== playerId);
                
                if (opponents.length > 0) {
                    damageRows = `<div class="damage-section"><h4 style="margin:0 0 10px 0; font-size:0.9em; color:#555;">Commander Damage Taken</h4>`;
                    opponents.forEach(oppId => {
                        const opp = roomData.players[oppId];
                        const dmg = player.commanderDamage?.[oppId] || 0;
                        const isLethal = dmg >= 21;
                        let dmgControls = '';
                        
                        if (isMe) {
                            dmgControls = `
                                <div class="control-group">
                                    <button class="btn-damage" data-opp="${oppId}" data-val="-1">-</button>
                                    <button class="btn-damage" data-opp="${oppId}" data-val="+1">+</button>
                                </div>
                            `;
                        }
                        
                        damageRows += `
                            <div class="damage-row">
                                <span style="font-size:0.9em;">From **${opp.name}** [${opp.commander || 'N/A'}]</span>
                                <div style="display:flex; align-items:center; gap:10px;">
                                    <input 
                                        type="number" 
                                        min="0"
                                        value="${dmg}" 
                                        data-opp="${oppId}"
                                        class="damage-input ${isLethal ? 'lethal' : ''}"
                                        onchange="updateCmdDamageDirectly(this.dataset.opp, this.value)"
                                        style="width: 50px;"
                                    >
                                    ${dmgControls}
                                </div>
                            </div>
                        `;
                    });
                    damageRows += `</div>`;
                }

                html += `
                    <div class="player-counter" style="${isMe ? 'border: 2px solid #3498db;' : ''}">
                        <div class="life-section">
                            <div class="life-display">
                                <div class="player-name-display">${isMe ? 'YOU' : player.name}</div>
                                <div class="cmd-name">[${player.commander || 'N/A'}]</div>
                                ${lifeDisplayHtml}
                            </div>
                            ${lifeControls}
                        </div>
                        ${damageRows}
                    </div>
                `;
            });
            
            // --- Chat Container ---
            html += `
                <div id="chat-container">
                    <h3 style="margin-bottom: 10px;">Game Chat</h3>
                    <div id="chat-log"></div>
                    <form id="chat-input-form">
                        <input type="text" id="chat-message-input" placeholder="Type message..." maxlength="150" required>
                        <button type="submit">Send</button>
                    </form>
                </div>
            `;
            
            // --- Lobby Features ---
            html += `
                <div id="lobby-features">
                    <h3 style="width:100%; margin-bottom: 5px;">Game Tools</h3>
                    <button id="roll-dice-btn">Roll D20</button>
                    <div id="roll-result" style="width:40%; text-align:center;">-</div>
                    <button id="turn-order-btn">Determine Turn Order</button>
                    <button id="card-search-btn">Card Search</button>
                    <button id="share-invite-btn">Share Invite Link</button>
                </div>
                <button id="leave-room-btn" class="btn-danger">Leave Room</button>
            `;

            appContainer.innerHTML = html;
            
            // --- RENDER CHAT LOG ---
            renderChat(roomData.chatLog || [], currentPlayerName);


            // --- ATTACH LISTENERS ---
            document.querySelectorAll('.btn-life').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    updateLife(parseInt(e.target.dataset.val));
                });
            });

            document.querySelectorAll('.btn-damage').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    updateCmdDamage(e.target.dataset.opp, parseInt(e.target.dataset.val));
                });
            });

            document.getElementById('chat-input-form').addEventListener('submit', (e) => {
                e.preventDefault();
                const input = document.getElementById('chat-message-input');
                const message = input.value.trim();
                if (message) {
                    sendChatMessage(message, currentPlayerName);
                    input.value = '';
                }
            });
            
            // Share Invite Link Listener
            document.getElementById('share-invite-btn').addEventListener('click', () => {
                const roomUrl = `${window.location.origin}${window.location.pathname}?roomID=${roomId}`;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(roomUrl)
                        .then(() => alert(`Invite link copied to clipboard: ${roomUrl}`))
                        .catch(err => console.error('Could not copy text: ', err));
                } else {
                    prompt(`Invite link (Copy Manually):`, roomUrl);
                }
            });

            document.getElementById('leave-room-btn').addEventListener('click', () => {
                if(unsubscribe) unsubscribe();
                roomId = null;
                // Clear URL param on leaving room
                window.history.pushState({}, document.title, window.location.pathname); 
                renderSetupView();
            });
            
            document.getElementById('refresh-btn').addEventListener('click', () => {
                if(roomId) listenToRoom(roomId);
            });

            document.getElementById('delete-room-btn').addEventListener('click', () => {
                if(confirm("Are you sure you want to delete this room for ALL players?")) {
                    deleteRoom(roomId);
                }
            });

            document.getElementById('roll-dice-btn').addEventListener('click', () => {
                const roll = Math.floor(Math.random() * 20) + 1;
                document.getElementById('roll-result').textContent = roll;
            });
            
            document.getElementById('turn-order-btn').addEventListener('click', () => {
                determineTurnOrder(roomData.players);
            });
            
            document.getElementById('card-search-btn').addEventListener('click', () => {
                document.getElementById('card-search-modal').style.display = 'flex';
                document.getElementById('modal-card-name').value = '';
                document.getElementById('search-results').innerHTML = '';
            });
            
            // Make updateCmdDamageDirectly and updateLifeDirectly globally accessible
            window.updateCmdDamageDirectly = updateCmdDamageDirectly; 
            window.updateLifeDirectly = updateLifeDirectly; // New global function
        }
        
        // --- CHAT DATA UPDATE FUNCTION ---

        async function sendChatMessage(message, senderName) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);

            const chatMessage = {
                senderId: userId,
                senderName: senderName,
                message: message,
                timestamp: Date.now()
            };
            
            try {
                await setDoc(ref, {
                    chatLog: arrayUnion(chatMessage),
                    lastActive: serverTimestamp()
                }, { merge: true });

            } catch(e) { 
                console.error("Error sending chat message:", e);
            }
        }


        // --- DATA UPDATES ---
        
        // NEW: Function to handle direct life total input changes
        async function updateLifeDirectly(newValue) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);

            // Clean input: ensure it's an integer (can be negative)
            const newLife = parseInt(newValue) || 0;

            try {
                const snap = await getDoc(ref);
                if (!snap.exists()) return;

                await setDoc(ref, {
                    players: { [userId]: { life: newLife } },
                    lastActive: serverTimestamp()
                }, { merge: true });

            } catch(e) { console.error("Error setting life total directly:", e); }
        }


        async function updateLife(delta) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);
            try {
                const snap = await getDoc(ref);
                if (snap.exists()) {
                    const data = snap.data();
                    const cur = data.players[userId]?.life ?? getStartingLife();
                    
                    // Call the direct update function to save the new value
                    await updateLifeDirectly(cur + delta);
                }
            } catch(e) { console.error(e); }
        }

        async function updateCmdDamage(oppId, delta) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);
            try {
                const snap = await getDoc(ref);
                if (snap.exists()) {
                    const data = snap.data();
                    
                    const currentPlayer = data.players[userId];
                    if (!currentPlayer) return;

                    const currentDamageMap = currentPlayer.commanderDamage || {};
                    const currentDamage = currentDamageMap[oppId] || 0;
                    const newDamage = Math.max(0, currentDamage + delta); 

                    // Call the direct update function to save the new value
                    await updateCmdDamageDirectly(oppId, newDamage);

                }
            } catch(e) { console.error("Error updating commander damage:", e); }
        }
        
        // Function to handle direct commander damage input changes
        async function updateCmdDamageDirectly(oppId, newValue) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);

            // Clean and validate input: ensure it's a non-negative integer
            const newDamage = Math.max(0, parseInt(newValue) || 0);

            try {
                const snap = await getDoc(ref);
                if (!snap.exists()) return;

                const data = snap.data();
                const currentPlayer = data.players[userId];
                if (!currentPlayer) return;

                const currentDamageMap = currentPlayer.commanderDamage || {};
                currentDamageMap[oppId] = newDamage;

                await setDoc(ref, {
                    players: { 
                        [userId]: { 
                            ...currentPlayer,
                            commanderDamage: currentDamageMap
                        } 
                    },
                    lastActive: serverTimestamp()
                }, { merge: true });

            } catch(e) { console.error("Error setting commander damage directly:", e); }
        }


        // --- SETUP & LIST VIEWS ---
        
        async function deleteAllRooms() {
            const password = prompt("Enter the global deletion password to confirm this action:");
            
            if (password !== DELETE_ALL_PWD) {
                alert("Incorrect password. All rooms were NOT deleted.");
                return;
            }

            if (!confirm("LAST WARNING: Are you absolutely sure you want to delete ALL rooms? This cannot be undone.")) {
                return;
            }

            document.getElementById("status-message").textContent = "Deleting all rooms...";
            const roomsRef = collection(db, ROOM_COLLECTION);
            
            try {
                const snapshot = await getDocs(roomsRef);
                let deleteCount = 0;

                for (const docSnapshot of snapshot.docs) {
                    await deleteDoc(doc(db, ROOM_COLLECTION, docSnapshot.id));
                    deleteCount++;
                }

                alert(`Success! Deleted ${deleteCount} room(s).`);
                renderSetupView(); 
            } catch (e) {
                console.error("Failed to delete all rooms:", e);
                alert("An error occurred during bulk deletion. Check the console.");
            }
        }

        function determineTurnOrder(players) {
            const playerNames = Object.values(players).map(p => p.name || 'Unknown Player');
            
            if (playerNames.length < 2) {
                alert("Need at least two players to determine turn order.");
                return;
            }

            for (let i = playerNames.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [playerNames[i], playerNames[j]] = [playerNames[j], playerNames[i]];
            }
            
            const orderText = `Turn Order:\n1. ${playerNames[0]}\n2. ${playerNames[1]}${playerNames[2] ? `\n3. ${playerNames[2]}` : ''}\n...`;
            alert(orderText);
        }

        async function deleteRoom(id) {
            if (!id) return;
            try {
                await deleteDoc(doc(db, ROOM_COLLECTION, id));
                if(unsubscribe) unsubscribe();
                roomId = null;
                renderSetupView();
            } catch (e) {
                alert("Failed to delete room. Check console for details.");
                console.error("Delete room failed:", e);
            }
        }
        
        function promptPassword(rid, mode) {
            const appContainer = document.getElementById("app-container");
            const title = mode === 'join' ? `Join Room: ${rid}` : `Create Room: ${rid}`;
            const btnText = mode === 'join' ? "Enter Game" : "Create Room";
            
            appContainer.innerHTML = `
                <h2>${title}</h2>
                <input type="text" id="player-name-input" placeholder="Your Player Name">
                <input type="text" id="commander-input" placeholder="Your Commander's Name (e.g., Urza)">
                <input type="password" id="pwd-input" placeholder="Room Password">
                <button id="action-btn" class="btn-primary">${btnText}</button>
                <button id="cancel-btn" class="btn-danger">Cancel</button> 
                <p id="err-msg" style="color:red"></p>
            `;
            
            document.getElementById("cancel-btn").onclick = () => {
                window.history.pushState({}, document.title, window.location.pathname); 
                renderSetupView();
            };
            
            document.getElementById("action-btn").onclick = async () => {
                const name = document.getElementById("player-name-input").value.trim();
                const commander = document.getElementById("commander-input").value.trim();
                const pwd = document.getElementById("pwd-input").value;
                if(!name || !pwd) return;
                
                if (mode === 'join') {
                    const ref = doc(db, ROOM_COLLECTION, rid);
                    const snap = await getDoc(ref);
                    if(snap.exists()) {
                        const data = snap.data();
                        if(await checkAndDeleteIfExpired(rid, data)) {
                            document.getElementById("err-msg").textContent = "Room expired and was deleted.";
                            setTimeout(renderSetupView, 2000);
                            return;
                        }
                        if(data.passwordHash === hashPassword(pwd)) {
                            listenToRoom(rid, name, commander); 
                        } else {
                            document.getElementById("err-msg").textContent = "Wrong password.";
                        }
                    } else {
                        document.getElementById("err-msg").textContent = "Room no longer exists.";
                    }
                } else {
                    if(pwd.length < 3) {
                        document.getElementById("err-msg").textContent = "Password too short.";
                        return;
                    }
                    createRoom(rid, pwd, name, commander); 
                }
            };
        }

        async function createRoom(rid, pwd, name, commander) {
            if(!userId) return;
            const ref = doc(db, ROOM_COLLECTION, rid);
            try {
                await setDoc(ref, {
                    ownerId: userId,
                    passwordHash: hashPassword(pwd),
                    createdAt: serverTimestamp(),
                    lastActive: serverTimestamp(),
                    chatLog: [], 
                    players: {
                        [userId]: { life: getStartingLife(), commanderDamage: {}, name: name, commander: commander }
                    }
                });
                listenToRoom(rid);
            } catch(e) {
                console.error(e);
            }
        }
        
        function listenToRoom(rid, newName = null, newCommander = null) {
            if(unsubscribe) unsubscribe();
            const ref = doc(db, ROOM_COLLECTION, rid);
            
            unsubscribe = onSnapshot(ref, (snap) => {
                if(snap.exists()) {
                    roomId = rid;
                    const data = snap.data();
                    
                    if(!data.players[userId]) {
                        if (newName && newCommander) {
                            setDoc(ref, {
                                players: { [userId]: { life: getStartingLife(), commanderDamage: {}, name: newName, commander: newCommander } },
                                lastActive: serverTimestamp()
                            }, { merge: true });
                        } else {
                            renderSetupView();
                            return;
                        }
                    }
                    
                    renderRoomView(data);
                } else {
                    renderSetupView();
                }
            });
        }

        async function renderSetupView() {
            const appContainer = document.getElementById("app-container");
            const statusMessage = document.getElementById("status-message");
            roomId = null;

            statusMessage.textContent = "Browse rooms or create a new one.";
            statusMessage.style.color = "#555"; 

            let listHtml = '<p>Loading active rooms...</p>';
            appContainer.innerHTML = `
                <h1 class="app-title">Cardboard Bonfire ðŸ”¥</h1> 
                <p class="app-subtitle">Life tracker for keeping life and bringing people together.</p> 
                
                <div style="margin-bottom:20px;">
                    <input type="text" id="search-input" placeholder="Enter Room ID to Create/Search">
                    <button id="search-btn" class="btn-primary">Find or Create Room</button>
                </div>
                <h3>Active Rooms</h3>
                <div id="room-list-container">${listHtml}</div>
                <button id="delete-all-rooms-btn">Delete All Rooms (Admin)</button> 
            `;

            try {
                const q = query(collection(db, ROOM_COLLECTION), limit(15));
                const snap = await getDocs(q);
                
                if (snap.empty) {
                    listHtml = '<p>No active rooms. Create one above!</p>';
                } else {
                    listHtml = '';
                    snap.forEach(docSnap => {
                        const rData = docSnap.data();
                        const rId = docSnap.id;
                        const pCount = Object.keys(rData.players || {}).length;
                        const ownerName = rData.players[rData.ownerId]?.name || 'Owner';
                        const ownerCmd = rData.players[rData.ownerId]?.commander || 'N/A';
                        
                        listHtml += `
                            <div class="room-item">
                                <div class="room-info">
                                    <span class="room-id">${rId}</span>
                                    <span class="room-meta">${pCount} Player(s) | Owner: ${ownerName} [${ownerCmd}]</span>
                                </div>
                                <button class="join-btn btn-secondary" data-rid="${rId}">Join</button>
                            </div>
                        `;
                    });
                }
            } catch (e) {
                console.error("List error:", e);
                listHtml = `<p style="color:red">Error loading rooms. Permissions might be initializing...</p>`;
            }

            const listContainer = document.getElementById("room-list-container");
            if(listContainer) listContainer.innerHTML = listHtml;

            if(listContainer) {
                listContainer.querySelectorAll('.join-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        promptPassword(e.target.dataset.rid, 'join');
                    });
                });
            }

            document.getElementById("search-btn").onclick = async () => {
                const val = document.getElementById("search-input").value.trim().toLowerCase();
                if(!val) return;
                
                const snap = await getDoc(doc(db, ROOM_COLLECTION, val));
                
                if(snap.exists()) {
                    promptPassword(val, 'join');
                } else {
                    promptPassword(val, 'create');
                }
            };
            
            document.getElementById("delete-all-rooms-btn").addEventListener('click', deleteAllRooms);
        }

        // --- Card Search Modal Logic ---
        document.getElementById('modal-close-btn').addEventListener('click', () => {
            document.getElementById('card-search-modal').style.display = 'none';
        });
        
        document.getElementById('modal-search-btn').addEventListener('click', async () => {
            const cardName = document.getElementById('modal-card-name').value.trim();
            const resultsDiv = document.getElementById('search-results');
            resultsDiv.innerHTML = '<p>Searching...</p>';

            if (!cardName) {
                resultsDiv.innerHTML = '<p>Please enter a card name.</p>';
                return;
            }

            try {
                const response = await fetch(`${SCRYFALL_API}${encodeURIComponent(cardName)}`);
                const data = await response.json();

                if (response.ok) {
                    const imgUrl = data.image_uris?.normal || data.card_faces?.[0]?.image_uris?.normal;
                    if (imgUrl) {
                        resultsDiv.innerHTML = `
                            <h4>${data.name}</h4>
                            <img src="${imgUrl}" alt="${data.name}">
                        `;
                    } else {
                        resultsDiv.innerHTML = '<p>Card found, but image unavailable.</p>';
                    }
                } else {
                    resultsDiv.innerHTML = `<p>Card not found. Check spelling.</p>`;
                }
            } catch (e) {
                resultsDiv.innerHTML = `<p>Error connecting to Scryfall.</p>`;
                console.error(e);
            }
        });

        // ----------------------------------------------------------------------
        // 6. INIT
        // ----------------------------------------------------------------------

        function checkURLParamsAndInitialize() {
            const params = new URLSearchParams(window.location.search);
            const idFromURL = params.get('roomID');

            if (idFromURL) {
                promptPassword(idFromURL, 'join');
            } else {
                renderSetupView();
            }
        }

        onAuthStateChanged(auth, user => {
            if(user) {
                userId = user.uid;
                checkURLParamsAndInitialize(); 
            } else {
                signInAnonymously(auth).catch(e => {
                    document.getElementById("status-message").textContent = "Auth Error: " + e.message;
                });
            }
        });

    </script>
</body>
</html>
