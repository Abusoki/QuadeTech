<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Life Tracker</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f4f4;
        }
        #app-container {
            width: 100%;
            max-width: 400px;
            background-color: white;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            border-radius: 8px;
        }
        /* Room List Styling */
        #room-list {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 15px;
        }
        .room-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .room-item:last-child {
            border-bottom: none;
        }
        .room-item:hover {
            background-color: #e9e9e9;
        }
        .room-item button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
        }
        /* Player Counter Styling */
        .player-counter {
            border: 1px solid #ccc;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 4px;
        }
        .life-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .damage-section {
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        .damage-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        .damage-total {
            font-weight: bold;
            width: 30px;
            text-align: center;
        }
        .life-total {
            font-size: 2em;
            font-weight: bold;
        }
        /* General Input/Button Styling */
        input[type="text"], input[type="password"] {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        button {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            box-sizing: border-box;
            border: none;
            border-radius: 4px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
        }
        #cancel-btn, #leave-room-btn {
            background-color: #f44336;
        }
        .life-control button, .damage-control button {
            width: auto;
            padding: 5px 10px;
            font-size: 1em;
            margin: 0 2px;
            background-color: #007bff;
        }
        #status-message {
            color: #333;
            margin-top: 10px;
            text-align: center;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
</head>
<body>

    <div id="app-container">
        </div>

    <p id="status-message">Initializing...</p>

    <script type="module">
        // ----------------------------------------------------------------------
        // ðŸ”‘ 1. CONFIGURATION (REPLACE WITH YOUR ACTUAL FIREBASE VALUES)
        // ----------------------------------------------------------------------
        const USER_FIREBASE_CONFIG = {
            apiKey: "AIzaSyA_mz_fVsph8VHfCEG__9sWg_ZvwYX5_6E", 
            authDomain: "mtg-life-tool.firebaseapp.com",
            projectId: "mtg-life-tool", 
            storageBucket: "mtg-life-tool.appspot.com",
            messagingSenderId: "36730058988",
            appId: "1:36730058988:web:757e2d9620593b4f65022a",
            measurementId: "G-GGL1Q6R00X"
        };
        
        // ----------------------------------------------------------------------
        // ðŸ“š 2. IMPORTS
        // ----------------------------------------------------------------------
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, 
            signInAnonymously, 
            onAuthStateChanged 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, 
            doc, 
            setDoc, 
            getDoc, 
            onSnapshot, 
            serverTimestamp,
            collection,
            getDocs,
            query,
            limit,
            deleteDoc
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ----------------------------------------------------------------------
        // âš™ï¸ 3. GLOBALS
        // ----------------------------------------------------------------------
        const app = initializeApp(USER_FIREBASE_CONFIG);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let userId = null;
        let roomId = null;
        let unsubscribe = null;
        const ROOM_COLLECTION = "mtg_rooms";
        const TIMEOUT_MINUTES = 25; // Rooms timeout after 25 minutes of inactivity

        // ----------------------------------------------------------------------
        // ðŸ”’ 4. PASSWORD HASHING FUNCTION
        // ----------------------------------------------------------------------

        function hashPassword(password) {
            return CryptoJS.SHA256(password).toString(CryptoJS.enc.Hex);
        }

        // ----------------------------------------------------------------------
        // ðŸ—‘ï¸ 5. ROOM CLEANUP LOGIC (New Feature)
        // ----------------------------------------------------------------------

        /**
         * Checks if a room has expired based on the lastActive timestamp.
         * If expired, deletes the room and redirects to setup.
         * @param {string} id - The room ID to check.
         * @param {object} roomData - The current room data.
         * @returns {boolean} - True if the room was deleted, false otherwise.
         */
        async function checkAndDeleteIfExpired(id, roomData) {
            const lastActive = roomData.lastActive?.toDate();
            const currentTime = new Date();
            
            if (lastActive) {
                const elapsedMinutes = (currentTime.getTime() - lastActive.getTime()) / (1000 * 60);
                
                if (elapsedMinutes > TIMEOUT_MINUTES) {
                    console.log(`Room ${id} expired after ${elapsedMinutes.toFixed(2)} minutes.`);
                    document.getElementById("status-message").innerHTML = `Room ${id} expired due to inactivity. Deleting...`;
                    
                    try {
                        await deleteDoc(doc(db, ROOM_COLLECTION, id));
                    } catch (e) {
                        console.error("Error deleting expired room:", e);
                    }
                    
                    if (unsubscribe) unsubscribe();
                    roomId = null;
                    renderSetupView();
                    return true;
                }
            }
            return false;
        }

        // ----------------------------------------------------------------------
        // ðŸ§© 6. CORE GAME LOGIC (Modified)
        // ----------------------------------------------------------------------

        function getStartingLife() {
            return 40; 
        }

        /** Creates the initial commander damage object for a new player */
        function getStartingCommanderDamage(playerIds) {
            const damage = {};
            playerIds.forEach(id => {
                if (id !== userId) {
                    // Initialize damage taken from other commanders to 0
                    damage[id] = 0; 
                }
            });
            return damage;
        }

        function renderRoomView(roomData) {
            const appContainer = document.getElementById("app-container");
            const statusMessage = document.getElementById("status-message");

            if (!roomData || !roomData.players) {
                appContainer.innerHTML = '<h2>Room Data Error</h2><p>Could not load player data.</p>';
                return;
            }

            statusMessage.innerHTML = `Room ID: <strong>${roomId}</strong> | Inactive in: ${TIMEOUT_MINUTES} min.`;
            
            let html = `<h2>Current Game State</h2>`;
            const playerIds = Object.keys(roomData.players);

            playerIds.forEach(playerId => {
                const player = roomData.players[playerId];
                const isCurrentPlayer = playerId === userId;
                
                // --- Life Section ---
                let lifeHtml = `
                    <div class="life-section">
                        <div>
                            <p><strong>${isCurrentPlayer ? 'You' : `Player (${playerId.substring(0, 4)}...)`}</strong></p>
                            <p>Life: <span class="life-total">${player.life}</span></p>
                        </div>
                        ${isCurrentPlayer ? `
                            <div class="life-control">
                                <button data-player-id="${playerId}" data-type="life" data-delta="-5">-5</button>
                                <button data-player-id="${playerId}" data-type="life" data-delta="-1">-1</button>
                                <button data-player-id="${playerId}" data-type="life" data-delta="+1">+1</button>
                                <button data-player-id="${playerId}" data-type="life" data-delta="+5">+5</button>
                            </div>
                        ` : ''}
                    </div>
                `;

                // --- Commander Damage Section ---
                let damageHtml = `<div class="damage-section"><h4>Commander Damage Taken:</h4>`;
                
                // List damage taken from *other* players' commanders
                const opponents = playerIds.filter(id => id !== playerId);

                if (opponents.length === 0) {
                     damageHtml += '<p>No opponents yet.</p>';
                } else {
                    opponents.forEach(opponentId => {
                        const damage = player.commanderDamage?.[opponentId] || 0;

                        damageHtml += `
                            <div class="damage-row">
                                <span>From ${opponentId.substring(0, 4)}...:</span>
                                <span class="damage-total">${damage}</span>
                                ${isCurrentPlayer ? `
                                    <div class="damage-control">
                                        <button data-player-id="${playerId}" data-opponent-id="${opponentId}" data-type="commander" data-delta="-1">-1</button>
                                        <button data-player-id="${playerId}" data-opponent-id="${opponentId}" data-type="commander" data-delta="+1">+1</button>
                                    </div>
                                ` : `<div style="width: 70px;"></div>`}
                            </div>
                        `;
                    });
                }
                damageHtml += `</div>`;

                html += `<div class="player-counter" id="player-${playerId}">${lifeHtml}${damageHtml}</div>`;
            });

            html += `<button id="leave-room-btn" style="background-color: #6c757d;">Leave Room</button>`;

            appContainer.innerHTML = html;
            
            // Add listeners for ALL buttons
            if (isCurrentPlayer) {
                document.querySelectorAll('.life-control button').forEach(button => {
                    button.addEventListener('click', (e) => handleUpdate(e, 'life'));
                });
                document.querySelectorAll('.damage-control button').forEach(button => {
                    button.addEventListener('click', (e) => handleUpdate(e, 'commander'));
                });
            }

            document.getElementById('leave-room-btn').addEventListener('click', () => {
                if (unsubscribe) unsubscribe();
                roomId = null;
                renderSetupView();
            });
        }

        /** Handles all life and commander damage updates from button clicks */
        function handleUpdate(e, type) {
            const delta = parseInt(e.target.dataset.delta, 10);
            if (type === 'life') {
                updateLife(delta);
            } else if (type === 'commander') {
                const opponentId = e.target.dataset.opponentId;
                updateCommanderDamage(opponentId, delta);
            }
        }
        
        // FIX for #1: Ensure correct path to life total is read
        async function updateLife(delta) {
            if (!roomId || !userId) return;

            const roomRef = doc(db, ROOM_COLLECTION, roomId);

            try {
                const roomSnap = await getDoc(roomRef);
                if (roomSnap.exists()) {
                    const roomData = roomSnap.data();
                    
                    // FIX: Get life total from the nested structure
                    const currentLife = roomData.players?.[userId]?.life ?? getStartingLife(); 
                    const newLife = currentLife + delta;
                    
                    const updatePayload = {};
                    updatePayload[`players.${userId}.life`] = newLife;
                    updatePayload.lastActive = serverTimestamp(); // NEW: Update activity timestamp

                    await setDoc(roomRef, updatePayload, { merge: true });
                }
            } catch (error) {
                console.error("Error updating life:", error);
            }
        }

        // NEW FEATURE: Update commander damage
        async function updateCommanderDamage(opponentId, delta) {
            if (!roomId || !userId) return;
            
            const roomRef = doc(db, ROOM_COLLECTION, roomId);

            try {
                const roomSnap = await getDoc(roomRef);
                if (roomSnap.exists()) {
                    const roomData = roomSnap.data();
                    
                    // Read current damage from specific opponent
                    const currentDamage = roomData.players?.[userId]?.commanderDamage?.[opponentId] ?? 0;
                    const newDamage = Math.max(0, currentDamage + delta); // Damage cannot go below 0

                    const updatePayload = {};
                    // Path: players.[userId].commanderDamage.[opponentId]
                    updatePayload[`players.${userId}.commanderDamage.${opponentId}`] = newDamage;
                    updatePayload.lastActive = serverTimestamp(); // NEW: Update activity timestamp

                    await setDoc(roomRef, updatePayload, { merge: true });
                }
            } catch (error) {
                console.error("Error updating commander damage:", error);
            }
        }
        
        // --- Setup and Flow Functions (Minimal changes to integrate new logic) ---

        function listenToRoom(id) {
            if (unsubscribe) {
                unsubscribe();
            }

            const roomRef = doc(db, ROOM_COLLECTION, id);
            
            unsubscribe = onSnapshot(roomRef, async (docSnap) => {
                if (docSnap.exists()) {
                    const roomData = docSnap.data();
                    
                    // NEW: Check for room expiry immediately upon receiving data
                    if (await checkAndDeleteIfExpired(id, roomData)) {
                        return; // Stop processing if the room was deleted
                    }

                    if (roomData.players && roomData.players[userId]) {
                        roomId = id;
                        renderRoomView(roomData);
                    } else {
                        roomId = id;
                        // User is verified, but not in player list. Join them automatically.
                        joinRoom(id, roomData); 
                    }
                } else {
                    // Room does not exist (e.g., deleted by checkAndDeleteIfExpired or manual delete)
                    if (unsubscribe) unsubscribe();
                    roomId = null; 
                    renderSetupView();
                }
            }, (error) => {
                console.error("Firestore listener error:", error);
                document.getElementById("status-message").innerHTML = `Error accessing room: ${error.message}`;
                renderSetupView(); 
            });
        }
        
        async function joinRoom(id, roomData) {
            if (!userId) return;
            
            const roomRef = doc(db, ROOM_COLLECTION, id);
            
            // Get all current player IDs to correctly initialize commander damage
            const currentPlayerIds = Object.keys(roomData.players || {});
            currentPlayerIds.push(userId); // Include the user being added

            const playerPayload = {
                life: getStartingLife(),
                joinedAt: serverTimestamp(),
                // NEW: Initialize commander damage for the new player
                commanderDamage: getStartingCommanderDamage(currentPlayerIds) 
            };
            
            const updatePayload = {};
            updatePayload[`players.${userId}`] = playerPayload;
            updatePayload.lastActive = serverTimestamp(); // NEW: Update activity timestamp

            try {
                await setDoc(roomRef, updatePayload, { merge: true });
                // Note: The listener will update the UI after this write.
            } catch (error) {
                console.error("Error joining room:", error);
                document.getElementById("status-message").innerHTML = "Error joining room. Try again.";
            }
        }
        
        async function createNewRoom(id, password) {
            if (!userId) return;

            const roomRef = doc(db, ROOM_COLLECTION, id);
            
            const initialRoomData = {
                roomId: id,
                ownerId: userId,
                passwordHash: hashPassword(password), 
                createdAt: serverTimestamp(),
                lastActive: serverTimestamp(), // NEW: Initial activity timestamp
                players: {
                    [userId]: {
                        life: getStartingLife(),
                        joinedAt: serverTimestamp(),
                        // NEW: Initial commander damage (will be empty since there are no opponents yet)
                        commanderDamage: {} 
                    }
                }
            };
            
            try {
                await setDoc(roomRef, initialRoomData, { merge: false });
                listenToRoom(id); 
            } catch (error) {
                console.error("Error creating room:", error);
                document.getElementById("status-message").innerHTML = "Error creating room. The ID might be taken.";
            }
        }
        
        // --- Unchanged Flow and Setup Functions (Omitted for brevity, but remain the same) ---
        
        function promptForPassword(id) {
            const appContainer = document.getElementById("app-container");
            document.getElementById("status-message").innerHTML = `Enter password for <strong>${id}</strong>.`;
            
            appContainer.innerHTML = `
                <h2>Join Room: ${id}</h2>
                <input type="password" id="room-password" placeholder="Enter Room Password">
                <button id="submit-password-btn">Join Game</button>
                <button id="cancel-btn">Cancel</button>
                <p id="password-error" style="color: red;"></p>
            `;

            document.getElementById('submit-password-btn').addEventListener('click', async () => {
                const password = document.getElementById('room-password').value;
                if (!password) return;

                const roomRef = doc(db, ROOM_COLLECTION, id);
                const roomSnap = await getDoc(roomRef);

                if (roomSnap.exists()) {
                    const roomData = roomSnap.data();
                    if (roomData.passwordHash === hashPassword(password)) {
                        listenToRoom(id); 
                    } else {
                        document.getElementById('password-error').textContent = "Incorrect password.";
                    }
                } else {
                    document.getElementById('password-error').textContent = "Room not found.";
                }
            });

            document.getElementById('cancel-btn').addEventListener('click', () => {
                renderSetupView();
            });
        }

        function promptToCreateRoom(id) {
            const appContainer = document.getElementById("app-container");
            document.getElementById("status-message").innerHTML = `Room <strong>${id}</strong> not found. Set up a new one.`;

            appContainer.innerHTML = `
                <h2>Create Room: ${id}</h2>
                <input type="password" id="new-room-password" placeholder="Set Room Password (min 4 chars)">
                <button id="create-new-room-btn">Create Room ${id}</button>
                <button id="cancel-btn">Cancel</button>
            `;

            document.getElementById('create-new-room-btn').addEventListener('click', async () => {
                const password = document.getElementById('new-room-password').value;
                if (password.length >= 4) {
                    await createNewRoom(id, password); 
                } else {
                    document.getElementById("status-message").innerHTML = "Password must be at least 4 characters.";
                }
            });
            
            document.getElementById('cancel-btn').addEventListener('click', () => {
                renderSetupView();
            });
        }
        
        async function renderSetupView() {
            const appContainer = document.getElementById("app-container");
            roomId = null; 
            document.getElementById("status-message").innerHTML = "Select a room below or search to create a new one.";

            const roomsQuery = query(collection(db, ROOM_COLLECTION), limit(20));
            let roomListHtml = '';
            try {
                const querySnapshot = await getDocs(roomsQuery);
                if (querySnapshot.empty) {
                    roomListHtml = '<p>No active rooms found.</p>';
                } else {
                    querySnapshot.forEach(doc => {
                        const roomID = doc.id;
                        const roomData = doc.data();
                        
                        // NEW: Check for expiry before showing
                        if (checkAndDeleteIfExpired(roomID, roomData)) {
                             return; // Skip expired room
                        }

                        const playerCount = Object.keys(roomData.players || {}).length;
                        roomListHtml += `
                            <div class="room-item" data-room-id="${roomID}">
                                <span>${roomID} (${playerCount} players)</span>
                                <button data-room-id="${roomID}">Join</button>
                            </div>
                        `;
                    });
                }
            } catch (error) {
                console.error("Error fetching rooms:", error);
                roomListHtml = '<p style="color:red;">Error loading rooms. Try refreshing.</p>';
            }

            appContainer.innerHTML = `
                <h2>MTG Commander Tracker</h2>

                <input type="text" id="room-search" placeholder="Search for or enter new Room ID">
                <button id="search-btn">Search / Create</button>
                
                <h3>Active Rooms</h3>
                <div id="room-list">${roomListHtml}</div>
            `;

            document.getElementById('room-list').querySelectorAll('button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const selectedRoomId = e.target.dataset.roomId;
                    promptForPassword(selectedRoomId);
                });
            });

            document.getElementById('search-btn').addEventListener('click', async () => {
                const input = document.getElementById('room-search').value.trim().toLowerCase();
                if (!input) {
                    document.getElementById("status-message").innerHTML = "Please enter a Room ID.";
                    return;
                }
                
                const roomRef = doc(db, ROOM_COLLECTION, input);
                const roomSnap = await getDoc(roomRef);

                if (roomSnap.exists()) {
                    promptForPassword(input);
                } else {
                    promptToCreateRoom(input);
                }
            });
        }
        
        function renderApp() {
            renderSetupView();
        }

        function initializeFirebase() {
            document.getElementById("status-message").innerHTML = "Connecting to Firebase...";

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    renderApp();
                } else {
                    try {
                        await signInAnonymously(auth);
                    } catch (error) {
                        console.error("Anonymous Sign-In Failed:", error);
                        document.getElementById("status-message").innerHTML = "Authentication failed. Check Firebase config.";
                    }
                }
            });
        }

        initializeFirebase();

    </script>
</body>
</html>
