<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG Life Tracker</title>
    <style>
        /* --- DARK MODE BASE STYLES --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #1e1e1e; /* Dark Background */
            color: #f0f0f0; /* Light Text */
        }
        #app-container {
            width: 100%;
            max-width: 450px;
            background-color: #2c2c2c; /* Dark Card Background */
            padding: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            border-radius: 12px;
            position: relative; /* Needed for suggestions list positioning */
        }
        
        /* --- General Styles --- */
        input {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid #444; /* Darker border */
            border-radius: 6px;
            box-sizing: border-box;
            background-color: #383838; /* Dark input background */
            color: #f0f0f0; /* Light input text */
        }
        button {
            cursor: pointer;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            transition: transform 0.1s, opacity 0.2s;
        }

        /* --- Active/Tapped State Class for Fast Feedback --- */
        button:active,
        .tapped { 
            transform: scale(0.96);
        }
        
        /* --- Button Colors (Accents remain, but backgrounds are dark) --- */
        .btn-primary {
            width: 100%;
            padding: 12px;
            background-color: #27ae60; /* Darker Green */
            color: white;
            font-size: 1.1em;
            margin-top: 10px;
        }
        .btn-danger {
            width: 100%;
            padding: 12px;
            background-color: #c0392b; /* Darker Red */
            color: white;
            margin-top: 5px;
        }
        .btn-secondary {
            background-color: #555; /* Dark Gray Secondary */
            color: white;
            padding: 8px;
            margin-left: 5px;
        }
        
        /* --- Game View Styles --- */
        .player-counter {
            border: 1px solid #444;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            background-color: #333; /* Player block background */
        }
        .life-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        /* Editable life input style */
        .life-input {
            font-size: 2.5em;
            font-weight: 800;
            color: #e0e0e0; /* Light Text */
            width: 100px; 
            padding: 0;
            border: none;
            text-align: left;
            background: none;
            box-sizing: content-box;
            height: 1.5em; 
            line-height: 1.5em;
        }
        
        .life-total { /* Kept for opponents */
            font-size: 2.5em;
            font-weight: 800;
            color: #e0e0e0; 
        }

        .player-name-display {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 5px;
        }
        .cmd-name {
            font-size: 0.9em;
            color: #aaa; /* Lighter gray for subtext */
            position: relative; /* Needed for tooltip positioning */
            display: inline-block;
            cursor: help;
        }
        
        /* --- Tooltip/Card Hover Styles (Default: Above) --- */
        .card-tooltip {
            visibility: hidden;
            width: 250px;
            background-color: #1e1e1e;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 10; /* Ensure tooltip is above other elements */
            bottom: 125%; /* Position the tooltip ABOVE the text */
            left: 50%;
            margin-left: -125px; /* Center the tooltip */
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none; 
            border: 2px solid #2980b9;
        }
        
        /* --- Tooltip Class for positioning BELOW --- */
        .card-tooltip.bottom {
            top: 125%; /* Position the tooltip BELOW the text */
            bottom: auto; 
        }

        .card-tooltip img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
        }
        
        .cmd-name:hover .card-tooltip {
            visibility: visible;
            opacity: 1;
        }
        /* -------------------------------------- */


        .btn-life {
            padding: 8px 12px;
            font-size: 1em;
            background-color: #2980b9; /* Darker Blue */
            color: white;
        }
        .btn-damage {
            padding: 4px 8px;
            font-size: 0.9em;
            background-color: #c0392b; /* Darker Red */
            color: white;
        }
        .damage-section {
            background-color: #3a3a3a; /* Darker damage section background */
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
        }
        .damage-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #444; /* Darker separator */
        }
        .control-group {
            display: flex;
            gap: 5px;
        }
        
        /* Editable damage input style */
        .damage-input {
            width: 50px; 
            padding: 4px;
            text-align: center;
            font-weight: bold;
            font-size: 1em;
            margin: 0;
            height: auto;
            border: 1px solid #555;
            background-color: #444; /* Darker damage input background */
            color: #f0f0f0;
        }
        .damage-input.lethal {
            color: #ff5555; /* Brighter red for lethal */
            border-color: #ff5555;
        }

        /* --- Suggestions List Styles --- */
        #suggestions-list {
            position: absolute;
            width: calc(100% - 50px); /* Match input width */
            background-color: #383838;
            border: 1px solid #2980b9;
            border-top: none;
            max-height: 150px;
            overflow-y: auto;
            z-index: 100; 
            border-radius: 0 0 6px 6px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            margin-top: -10px; /* Pull it up under the input */
            left: 25px; /* Match padding */
        }
        .suggestion-item {
            padding: 8px 12px;
            cursor: pointer;
            color: #f0f0f0;
        }
        .suggestion-item:hover {
            background-color: #2980b9;
        }


        /* --- Lobby Features --- */
        #lobby-features button {
            background-color: #2980b9; /* Darker Blue */
            color: white;
            width: 48%;
            padding: 10px;
            margin-bottom: 10px;
        }
        #lobby-features {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 5px;
            margin-top: 10px;
            border-top: 1px solid #444;
            padding-top: 15px;
        }
        #roll-result {
            font-size: 1.5em;
            font-weight: bold;
            color: #e0e0e0;
            margin-left: 10px;
        }

        /* --- Chat Styles --- */
        #chat-container {
            margin-top: 20px;
            border-top: 1px solid #444;
            padding-top: 15px;
        }
        #chat-log {
            height: 150px;
            overflow-y: auto;
            border: 1px solid #555;
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 6px;
            background-color: #333; /* Chat log background */
            font-size: 0.9em;
        }
        .chat-sender {
            font-weight: bold;
            color: #74b9ff; /* Brighter blue for sender name */
            margin-right: 5px;
        }
        #chat-input-form {
            display: flex;
            gap: 5px;
        }
        #chat-input-form input {
            flex-grow: 1;
            margin: 0;
            padding: 8px;
        }
        #chat-input-form button {
            width: auto;
            padding: 8px 15px;
            background-color: #2980b9; /* Darker Blue */
            color: white;
        }
        
        /* --- Modal for Card Search --- */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none; 
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #333; /* Modal background */
            color: #f0f0f0; /* Ensure default text is light */
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 400px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.7);
        }
        #search-results img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            margin-top: 15px;
        }

        
        /* Global delete button style */
        #delete-all-rooms-btn {
            background-color: #a62a1c; /* Slightly less harsh red */
            color: white;
            padding: 10px 15px;
            margin-top: 20px;
            border-radius: 6px;
            font-size: 0.9em;
        }
        
        /* Title Styles */
        .app-title {
            color: #f0f0f0;
            margin-bottom: 5px;
            font-size: 2em;
        }
        .app-subtitle {
            color: #aaa;
            font-size: 0.9em;
            margin-bottom: 20px;
            font-style: italic;
        }
        
        #status-message {
            color: #aaa;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
</head>
<body>

    <div id="app-container">
        </div>

    <p id="status-message">Initializing...</p>

    <div id="card-search-modal" class="modal">
        <div class="modal-content">
            <h3>Card Search (Scryfall)</h3>
            <input type="text" id="modal-card-name" placeholder="Enter card name">
            <button id="modal-search-btn" class="btn-primary">Search</button>
            <div id="search-results"></div>
            <button id="modal-close-btn" class="btn-danger">Close</button>
        </div>
    </div>
    
    <script type="module">
        // ----------------------------------------------------------------------
        // 1. CONFIGURATION
        // ----------------------------------------------------------------------
        const USER_FIREBASE_CONFIG = {
            apiKey: "AIzaSyA_mz_fVsph8VHfCEG__9sWg_ZvwYX5_6E", 
            authDomain: "mtg-life-tool.firebaseapp.com",
            projectId: "mtg-life-tool", 
            storageBucket: "mtg-life-tool.appspot.com",
            messagingSenderId: "36730058988",
            appId: "1:36730058988:web:757e2d9620593b4f65022a"
        };
        const SCRYFALL_API = "https://api.scryfall.com/cards/named?exact=";
        const SCRYFALL_AUTOCOMPLETE_API = "https://api.scryfall.com/cards/autocomplete?q=";
        const TIMEOUT_MINUTES = 25; 
        const DELETE_ALL_PWD = "DeleteAllRooms"; 
        
        // ----------------------------------------------------------------------
        // 2. IMPORTS
        // ----------------------------------------------------------------------
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, serverTimestamp, arrayUnion, deleteDoc, collection, getDocs, query, limit } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ----------------------------------------------------------------------
        // 3. GLOBALS
        // ----------------------------------------------------------------------
        const app = initializeApp(USER_FIREBASE_CONFIG);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let userId = null;
        let roomId = null;
        let unsubscribe = null;
        let autocompleteTimeout = null;
        const ROOM_COLLECTION = "mtg_rooms";

        // ----------------------------------------------------------------------
        // 4. HELPERS
        // ----------------------------------------------------------------------
        function hashPassword(password) {
            return CryptoJS.SHA256(password).toString(CryptoJS.enc.Hex);
        }

        async function checkAndDeleteIfExpired(id, roomData) {
            const lastActive = roomData.lastActive?.toDate();
            if (lastActive) {
                const elapsed = (new Date() - lastActive) / (1000 * 60);
                if (elapsed > TIMEOUT_MINUTES) {
                    try { await deleteDoc(doc(db, ROOM_COLLECTION, id)); } catch(e){}
                    return true;
                }
            }
            return false;
        }
        
        function getStartingLife() {
            return 40; 
        }
        
        /**
         * Validates a card name against Scryfall and returns the official name and image URL.
         * @param {string} name - The commander name entered by the user.
         * @returns {object|null} - { validatedName, imageUrl } or null if not found.
         */
        async function validateCommander(name) {
            if (!name) return null;
            try {
                const response = await fetch(`${SCRYFALL_API}${encodeURIComponent(name)}`);
                const data = await response.json();
                
                if (response.ok) {
                    const imageUrl = data.image_uris?.normal || data.card_faces?.[0]?.image_uris?.normal;
                    
                    if (imageUrl) {
                        return {
                            validatedName: data.name,
                            imageUrl: imageUrl
                        };
                    }
                }
                return null;
            } catch (e) {
                console.error("Scryfall validation error:", e);
                return null;
            }
        }
        
        /**
         * Fetches and displays autocomplete suggestions for commander input.
         * @param {string} query - The current text in the commander input field.
         */
        async function fetchAutocompleteSuggestions(query) {
            const suggestionsList = document.getElementById('suggestions-list');
            if (!suggestionsList) return;
            suggestionsList.innerHTML = '';
            
            if (query.length < 2) return; 

            try {
                const response = await fetch(`${SCRYFALL_AUTOCOMPLETE_API}${encodeURIComponent(query)}`);
                const data = await response.json();

                if (response.ok && data.data && data.data.length > 0) {
                    data.data.slice(0, 5).forEach(suggestion => {
                        const item = document.createElement('div');
                        item.classList.add('suggestion-item');
                        item.textContent = suggestion;
                        item.onclick = () => {
                            document.getElementById('commander-input').value = suggestion;
                            suggestionsList.innerHTML = ''; // Clear suggestions after selection
                        };
                        suggestionsList.appendChild(item);
                    });
                }
            } catch (e) {
                console.error("Autocomplete error:", e);
            }
        }


        // ----------------------------------------------------------------------
        // 5. GAME LOGIC & RENDERING
        // ----------------------------------------------------------------------
        
        function renderChat(chatLog, playerName) {
            const chatLogDiv = document.getElementById('chat-log');
            if (!chatLogDiv) return;

            chatLogDiv.innerHTML = '';
            
            const displayLog = chatLog.slice(-20); 

            displayLog.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('chat-message');

                const senderSpan = document.createElement('span');
                senderSpan.classList.add('chat-sender');
                senderSpan.textContent = `${msg.senderName}:`;
                
                if (msg.senderName === playerName) {
                    senderSpan.style.color = '#74b9ff'; 
                }

                messageDiv.appendChild(senderSpan);
                messageDiv.appendChild(document.createTextNode(msg.message));
                chatLogDiv.appendChild(messageDiv);
            });

            chatLogDiv.scrollTop = chatLogDiv.scrollHeight;
        }

        function renderRoomView(roomData) {
            const appContainer = document.getElementById("app-container");
            const statusMessage = document.getElementById("status-message");

            document.getElementById('card-search-modal').style.display = 'none';

            const currentPlayerName = roomData.players[userId]?.name || 'You';
            statusMessage.innerHTML = `Connected as: <strong>${currentPlayerName}</strong>`;
            
            let html = `
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                    <h2 style="margin:0; color:#f0f0f0;">Room: ${roomId}</h2>
                    <div style="display:flex; gap:10px;">
                        <button id="delete-room-btn" class="btn-danger" style="width:auto; padding: 5px 10px;">Delete Room</button>
                        <button id="refresh-btn" class="btn-secondary" style="width:auto; padding: 5px 10px;">â†»</button>
                    </div>
                </div>
            `;
            
            const playerIds = Object.keys(roomData.players);
            playerIds.sort((a, b) => (a === userId ? -1 : b === userId ? 1 : 0));

            html += `<h3 style="margin-top:0; color:#f0f0f0;">Players</h3>`;

            playerIds.forEach(playerId => {
                const player = roomData.players[playerId];
                const isMe = playerId === userId;
                
                let lifeControls = '';
                let lifeDisplayHtml = ''; 
                
                if (isMe) {
                    // Current Player: Editable Life Total and Controls
                    lifeDisplayHtml = `
                        <input 
                            type="number" 
                            value="${player.life}" 
                            class="life-input"
                            onchange="updateLifeDirectly(this.value)"
                        >`;
                    
                    lifeControls = `
                        <div class="control-group">
                            <button class="btn-life" data-type="life" data-val="-1">-1</button>
                            <button class="btn-life" data-type="life" data-val="-5">-5</button>
                            <button class="btn-life" data-type="life" data-val="+1">+1</button>
                            <button class="btn-life" data-type="life" data-val="+5">+5</button>
                        </div>
                    `;
                } else {
                    // Opponent: Static Life Total
                    lifeDisplayHtml = `<span class="life-total">${player.life}</span>`;
                }
                
                // Commander Name with Hover
                const commanderName = player.commanderName || player.commander || 'N/A';
                
                // Use a generic placeholder if image URL is missing
                const commanderImage = player.commanderImageUrl || '';

                const commanderHtml = commanderImage ? `
                    <div class="cmd-name" id="cmd-name-${playerId}">
                        [${commanderName}]
                        <span class="card-tooltip">
                            <img src="${commanderImage}" alt="${commanderName}">
                        </span>
                    </div>
                ` : `<div class="cmd-name">[${commanderName}]</div>`;


                let damageRows = '';
                const opponents = playerIds.filter(id => id !== playerId);
                
                if (opponents.length > 0) {
                    damageRows = `<div class="damage-section"><h4 style="margin:0 0 10px 0; font-size:0.9em; color:#aaa;">Commander Damage Taken</h4>`;
                    opponents.forEach(oppId => {
                        const opp = roomData.players[oppId];
                        const dmg = player.commanderDamage?.[oppId] || 0;
                        const isLethal = dmg >= 21;
                        let dmgControls = '';
                        
                        if (isMe) {
                            dmgControls = `
                                <div class="control-group">
                                    <button class="btn-damage" data-opp="${oppId}" data-val="-1">-</button>
                                    <button class="btn-damage" data-opp="${oppId}" data-val="+1">+</button>
                                </div>
                            `;
                        }
                        
                        // Use the verified commander name for display
                        const oppCmdName = opp.commanderName || opp.commander || 'N/A';

                        damageRows += `
                            <div class="damage-row">
                                <span style="font-size:0.9em;">From **${opp.name}** [${oppCmdName}]</span>
                                <div style="display:flex; align-items:center; gap:10px;">
                                    <input 
                                        type="number" 
                                        min="0"
                                        value="${dmg}" 
                                        data-opp="${oppId}"
                                        class="damage-input ${isLethal ? 'lethal' : ''}"
                                        onchange="updateCmdDamageDirectly(this.dataset.opp, this.value)"
                                        style="width: 50px;"
                                    >
                                    ${dmgControls}
                                </div>
                            </div>
                        `;
                    });
                    damageRows += `</div>`;
                }

                html += `
                    <div class="player-counter" style="${isMe ? 'border: 2px solid #2980b9;' : ''}">
                        <div class="life-section">
                            <div class="life-display">
                                <div class="player-name-display">${isMe ? 'YOU' : player.name}</div>
                                ${commanderHtml}
                                ${lifeDisplayHtml}
                            </div>
                            ${lifeControls}
                        </div>
                        ${damageRows}
                    </div>
                `;
            });
            
            // --- Chat Container ---
            html += `
                <div id="chat-container">
                    <h3 style="margin-bottom: 10px; color:#f0f0f0;">Game Chat</h3>
                    <div id="chat-log"></div>
                    <form id="chat-input-form">
                        <input type="text" id="chat-message-input" placeholder="Type message..." maxlength="150" required>
                        <button type="submit">Send</button>
                    </form>
                </div>
            `;
            
            // --- Lobby Features ---
            html += `
                <div id="lobby-features">
                    <h3 style="width:100%; margin-bottom: 5px; color:#f0f0f0;">Game Tools</h3>
                    <button id="roll-dice-btn">Roll D20</button>
                    <div id="roll-result" style="width:40%; text-align:center;">-</div>
                    <button id="turn-order-btn">Determine Turn Order</button>
                    <button id="card-search-btn">Card Search</button>
                    <button id="share-invite-btn">Share Invite Link</button>
                </div>
                <button id="leave-room-btn" class="btn-danger">Leave Room</button>
            `;

            appContainer.innerHTML = html;
            
            // --- RENDER CHAT LOG ---
            renderChat(roomData.chatLog || [], currentPlayerName);


            // --- ATTACH LISTENERS ---
            
            // Tooltip Cutoff Fix
            playerIds.forEach(playerId => {
                const cmdElement = document.getElementById(`cmd-name-${playerId}`);
                if (cmdElement) {
                    const rect = cmdElement.getBoundingClientRect();
                    const tooltip = cmdElement.querySelector('.card-tooltip');
                    
                    if (tooltip) {
                        // Check if the element is in the top 30% of the viewport (or less than 200px from top)
                        if (rect.top < 200) { 
                            tooltip.classList.add('bottom');
                        } else {
                            tooltip.classList.remove('bottom');
                        }
                    }
                }
            });

            document.querySelectorAll('.btn-life').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.target.classList.add('tapped');
                    setTimeout(() => {
                        e.target.classList.remove('tapped');
                    }, 100); 

                    updateLife(parseInt(e.target.dataset.val));
                });
            });

            document.querySelectorAll('.btn-damage').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.target.classList.add('tapped');
                    setTimeout(() => {
                        e.target.classList.remove('tapped');
                    }, 100); 
                    
                    updateCmdDamage(e.target.dataset.opp, parseInt(e.target.dataset.val));
                });
            });

            document.getElementById('chat-input-form').addEventListener('submit', (e) => {
                e.preventDefault();
                const input = document.getElementById('chat-message-input');
                const message = input.value.trim();
                if (message) {
                    sendChatMessage(message, currentPlayerName);
                    input.value = '';
                }
            });
            
            // Share Invite Link Listener
            document.getElementById('share-invite-btn').addEventListener('click', () => {
                const roomUrl = `${window.location.origin}${window.location.pathname}?roomID=${roomId}`;

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(roomUrl)
                        .then(() => alert(`Invite link copied to clipboard: ${roomUrl}`))
                        .catch(err => console.error('Could not copy text: ', err));
                } else {
                    prompt(`Invite link (Copy Manually):`, roomUrl);
                }
            });

            document.getElementById('leave-room-btn').addEventListener('click', () => {
                if(unsubscribe) unsubscribe();
                roomId = null;
                // Clear URL param on leaving room
                window.history.pushState({}, document.title, window.location.pathname); 
                renderSetupView();
            });
            
            document.getElementById('refresh-btn').addEventListener('click', () => {
                if(roomId) listenToRoom(roomId);
            });

            document.getElementById('delete-room-btn').addEventListener('click', () => {
                if(confirm("Are you sure you want to delete this room for ALL players?")) {
                    deleteRoom(roomId);
                }
            });

            document.getElementById('roll-dice-btn').addEventListener('click', () => {
                const roll = Math.floor(Math.random() * 20) + 1;
                document.getElementById('roll-result').textContent = roll;
            });
            
            document.getElementById('turn-order-btn').addEventListener('click', () => {
                determineTurnOrder(roomData.players);
            });
            
            document.getElementById('card-search-btn').addEventListener('click', () => {
                document.getElementById('card-search-modal').style.display = 'flex';
                document.getElementById('modal-card-name').value = '';
                document.getElementById('search-results').innerHTML = '';
            });
            
            // Make updateCmdDamageDirectly and updateLifeDirectly globally accessible
            window.updateCmdDamageDirectly = updateCmdDamageDirectly; 
            window.updateLifeDirectly = updateLifeDirectly; 
        }
        
        // --- CHAT DATA UPDATE FUNCTION ---

        async function sendChatMessage(message, senderName) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);

            const chatMessage = {
                senderId: userId,
                senderName: senderName,
                message: message,
                timestamp: Date.now()
            };
            
            try {
                await setDoc(ref, {
                    chatLog: arrayUnion(chatMessage),
                    lastActive: serverTimestamp()
                }, { merge: true });

            } catch(e) { 
                console.error("Error sending chat message:", e);
            }
        }


        // --- DATA UPDATES ---
        
        // Function to handle direct life total input changes
        async function updateLifeDirectly(newValue) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);

            // Clean input: ensure it's an integer (can be negative)
            const newLife = parseInt(newValue) || 0;

            try {
                const snap = await getDoc(ref);
                if (!snap.exists()) return;

                await setDoc(ref, {
                    players: { [userId]: { life: newLife } },
                    lastActive: serverTimestamp()
                }, { merge: true });

            } catch(e) { console.error("Error setting life total directly:", e); }
        }


        async function updateLife(delta) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);
            try {
                const snap = await getDoc(ref);
                if (snap.exists()) {
                    const data = snap.data();
                    const cur = data.players[userId]?.life ?? getStartingLife();
                    
                    // Call the direct update function to save the new value
                    await updateLifeDirectly(cur + delta);
                }
            } catch(e) { console.error(e); }
        }

        async function updateCmdDamage(oppId, delta) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);
            try {
                const snap = await getDoc(ref);
                if (snap.exists()) {
                    const data = snap.data();
                    
                    const currentPlayer = data.players[userId];
                    if (!currentPlayer) return;

                    const currentDamageMap = currentPlayer.commanderDamage || {};
                    const currentDamage = currentDamageMap[oppId] || 0;
                    const newDamage = Math.max(0, currentDamage + delta); 

                    // Call the direct update function to save the new value
                    await updateCmdDamageDirectly(oppId, newDamage);

                }
            } catch(e) { console.error("Error updating commander damage:", e); }
        }
        
        // Function to handle direct commander damage input changes
        async function updateCmdDamageDirectly(oppId, newValue) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);

            // Clean and validate input: ensure it's a non-negative integer
            const newDamage = Math.max(0, parseInt(newValue) || 0);

            try {
                const snap = await getDoc(ref);
                if (!snap.exists()) return;

                const data = snap.data();
                const currentPlayer = data.players[userId];
                if (!currentPlayer) return;

                const currentDamageMap = currentPlayer.commanderDamage || {};
                currentDamageMap[oppId] = newDamage;

                await setDoc(ref, {
                    players: { 
                        [userId]: { 
                            ...currentPlayer,
                            commanderDamage: currentDamageMap
                        } 
                    },
                    lastActive: serverTimestamp()
                }, { merge: true });

            } catch(e) { console.error("Error setting commander damage directly:", e); }
        }


        // --- SETUP & LIST VIEWS ---
        
        async function deleteAllRooms() {
            const password = prompt("Enter the global deletion password to confirm this action:");
            
            if (password !== DELETE_ALL_PWD) {
                alert("Incorrect password. All rooms were NOT deleted.");
                return;
            }

            if (!confirm("LAST WARNING: Are you absolutely sure you want to delete ALL rooms? This cannot be undone.")) {
                return;
            }

            document.getElementById("status-message").textContent = "Deleting all rooms...";
            const roomsRef = collection(db, ROOM_COLLECTION);
            
            try {
                const snapshot = await getDocs(roomsRef);
                let deleteCount = 0;

                for (const docSnapshot of snapshot.docs) {
                    await deleteDoc(doc(db, ROOM_COLLECTION, docSnapshot.id));
                    deleteCount++;
                }

                alert(`Success! Deleted ${deleteCount} room(s).`);
                renderSetupView(); 
            } catch (e) {
                console.error("Failed to delete all rooms:", e);
                alert("An error occurred during bulk deletion. Check the console.");
            }
        }

        function determineTurnOrder(players) {
            const playerNames = Object.values(players).map(p => p.name || 'Unknown Player');
            
            if (playerNames.length < 2) {
                alert("Need at least two players to determine turn order.");
                return;
            }

            for (let i = playerNames.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [playerNames[i], playerNames[j]] = [playerNames[j], playerNames[i]];
            }
            
            const orderText = `Turn Order:\n1. ${playerNames[0]}\n2. ${playerNames[1]}${playerNames[2] ? `\n3. ${playerNames[2]}` : ''}\n...`;
            alert(orderText);
        }

        async function deleteRoom(id) {
            if (!id) return;
            try {
                await deleteDoc(doc(db, ROOM_COLLECTION, id));
                if(unsubscribe) unsubscribe();
                roomId = null;
                renderSetupView();
            } catch (e) {
                alert("Failed to delete room. Check console for details.");
                console.error("Delete room failed:", e);
            }
        }
        
        function promptPassword(rid, mode) {
            const appContainer = document.getElementById("app-container");
            const title = mode === 'join' ? `Join Room: ${rid}` : `Create Room: ${rid}`;
            const btnText = mode === 'join' ? "Enter Game" : "Create Room";
            
            document.getElementById('card-search-modal').style.display = 'none';

            appContainer.innerHTML = `
                <h2 style="color:#f0f0f0;">${title}</h2>
                <input type="text" id="player-name-input" placeholder="Your Player Name">
                <input type="text" id="commander-input" placeholder="Your Commander's Name (Required)">
                <div id="suggestions-list"></div> <input type="password" id="pwd-input" placeholder="Room Password">
                <button id="action-btn" class="btn-primary">${btnText}</button>
                <button id="cancel-btn" class="btn-danger">Cancel</button> 
                <p id="err-msg" style="color:#ff5555;"></p>
            `;
            
            // --- Commander Input Autocomplete Listener ---
            const commanderInput = document.getElementById('commander-input');
            const suggestionsList = document.getElementById('suggestions-list');
            
            commanderInput.addEventListener('input', () => {
                const query = commanderInput.value.trim();
                if (autocompleteTimeout) clearTimeout(autocompleteTimeout);
                
                if (query.length >= 2) {
                    autocompleteTimeout = setTimeout(() => {
                        fetchAutocompleteSuggestions(query);
                    }, 300); // Debounce to prevent flooding Scryfall API
                } else {
                    suggestionsList.innerHTML = '';
                }
            });

            // Clear suggestions when clicking outside
            document.addEventListener('click', (e) => {
                if(suggestionsList && !commanderInput.contains(e.target) && !suggestionsList.contains(e.target)) {
                    suggestionsList.innerHTML = '';
                }
            });
            // ----------------------------------------------------
            
            document.getElementById("cancel-btn").onclick = () => {
                window.history.pushState({}, document.title, window.location.pathname); 
                renderSetupView();
            };
            
            document.getElementById("action-btn").onclick = async () => {
                const name = document.getElementById("player-name-input").value.trim();
                const commander = document.getElementById("commander-input").value.trim();
                const pwd = document.getElementById("pwd-input").value;
                const errMsg = document.getElementById("err-msg");
                
                if(!name || !pwd || !commander) {
                    errMsg.textContent = "Player Name, Commander, and Password are required.";
                    return;
                }
                
                errMsg.textContent = "Verifying commander and joining...";
                document.getElementById("action-btn").disabled = true;

                const validationResult = await validateCommander(commander);

                if (!validationResult) {
                    errMsg.textContent = `Commander "${commander}" not found on Scryfall. Please check spelling or use the Card Search tool.`;
                    document.getElementById("action-btn").disabled = false;
                    return;
                }
                
                const { validatedName, imageUrl } = validationResult;
                
                if (mode === 'join') {
                    const ref = doc(db, ROOM_COLLECTION, rid);
                    const snap = await getDoc(ref);
                    
                    if(snap.exists()) {
                        const data = snap.data();
                        if(await checkAndDeleteIfExpired(rid, data)) {
                            errMsg.textContent = "Room expired and was deleted.";
                            setTimeout(renderSetupView, 2000);
                            return;
                        }
                        if(data.passwordHash === hashPassword(pwd)) {
                            // Pass validated commander data to listenToRoom
                            listenToRoom(rid, name, validatedName, imageUrl); 
                        } else {
                            errMsg.textContent = "Wrong password.";
                            document.getElementById("action-btn").disabled = false;
                        }
                    } else {
                        errMsg.textContent = "Room no longer exists.";
                        document.getElementById("action-btn").disabled = false;
                    }
                } else {
                    if(pwd.length < 3) {
                        errMsg.textContent = "Password too short.";
                        document.getElementById("action-btn").disabled = false;
                        return;
                    }
                    // Pass validated commander data to createRoom
                    createRoom(rid, pwd, name, validatedName, imageUrl); 
                }
            };
        }

        async function createRoom(rid, pwd, name, commanderName, commanderImageUrl) {
            if(!userId) return;
            const ref = doc(db, ROOM_COLLECTION, rid);
            try {
                await setDoc(ref, {
                    ownerId: userId,
                    passwordHash: hashPassword(pwd),
                    createdAt: serverTimestamp(),
                    lastActive: serverTimestamp(),
                    chatLog: [], 
                    players: {
                        [userId]: { 
                            life: getStartingLife(), 
                            commanderDamage: {}, 
                            name: name, 
                            commanderName: commanderName,
                            commanderImageUrl: commanderImageUrl
                        }
                    }
                });
                listenToRoom(rid);
            } catch(e) {
                console.error(e);
            }
        }
        
        function listenToRoom(rid, newName = null, newCommanderName = null, newCommanderImageUrl = null) {
            if(unsubscribe) unsubscribe();
            const ref = doc(db, ROOM_COLLECTION, rid);
            
            unsubscribe = onSnapshot(ref, (snap) => {
                if(snap.exists()) {
                    roomId = rid;
                    const data = snap.data();
                    
                    if(!data.players[userId]) {
                        if (newName && newCommanderName && newCommanderImageUrl) {
                            // Joining existing room with new, validated data
                            setDoc(ref, {
                                players: { 
                                    [userId]: { 
                                        life: getStartingLife(), 
                                        commanderDamage: {}, 
                                        name: newName, 
                                        commanderName: newCommanderName,
                                        commanderImageUrl: newCommanderImageUrl
                                    } 
                                },
                                lastActive: serverTimestamp()
                            }, { merge: true });
                        } else {
                            // Should not happen if promptPassword worked, but handles safety
                            renderSetupView();
                            return;
                        }
                    }
                    
                    renderRoomView(data);
                } else {
                    renderSetupView();
                }
            });
        }

        async function renderSetupView() {
            const appContainer = document.getElementById("app-container");
            const statusMessage = document.getElementById("status-message");
            roomId = null;

            document.getElementById('card-search-modal').style.display = 'none';

            statusMessage.textContent = "Browse rooms or create a new one.";
            statusMessage.style.color = "#aaa"; 

            let listHtml = '<p style="color:#f0f0f0;">Loading active rooms...</p>';
            appContainer.innerHTML = `
                <h1 class="app-title">Cardboard Bonfire ðŸ”¥</h1> 
                <p class="app-subtitle">Life tracker for keeping life and bringing people together.</p> 
                
                <div style="margin-bottom:20px;">
                    <input type="text" id="search-input" placeholder="Enter Room ID to Create/Search">
                    <button id="search-btn" class="btn-primary">Find or Create Room</button>
                </div>
                <h3 style="color:#f0f0f0;">Active Rooms</h3>
                <div id="room-list-container">${listHtml}</div>
                <button id="delete-all-rooms-btn">Delete All Rooms (Admin)</button> 
            `;

            try {
                const q = query(collection(db, ROOM_COLLECTION), limit(15));
                const snap = await getDocs(q);
                
                if (snap.empty) {
                    listHtml = '<p style="color:#f0f0f0;">No active rooms. Create one above!</p>';
                } else {
                    listHtml = '';
                    snap.forEach(docSnap => {
                        const rData = docSnap.data();
                        const rId = docSnap.id;
                        const pCount = Object.keys(rData.players || {}).length;
                        
                        // Attempt to grab owner's validated commander name
                        const ownerCmdName = rData.players[rData.ownerId]?.commanderName || rData.players[rData.ownerId]?.commander || 'N/A';
                        const ownerName = rData.players[rData.ownerId]?.name || 'Owner';
                        
                        listHtml += `
                            <div class="room-item" style="display:flex; justify-content:space-between; align-items:center; background-color:#383838; padding: 10px; margin-bottom: 8px; border-radius: 4px;">
                                <div class="room-info">
                                    <span class="room-id" style="font-weight:bold; color:#f0f0f0;">${rId}</span>
                                    <span class="room-meta" style="font-size:0.9em; color:#aaa; display:block;">${pCount} Player(s) | Owner: ${ownerName} [${ownerCmdName}]</span>
                                </div>
                                <button class="join-btn btn-secondary" data-rid="${rId}" style="width:auto;">Join</button>
                            </div>
                        `;
                    });
                }
            } catch (e) {
                console.error("List error:", e);
                listHtml = `<p style="color:#ff5555;">Error loading rooms. Permissions might be initializing...</p>`;
            }

            const listContainer = document.getElementById("room-list-container");
            if(listContainer) listContainer.innerHTML = listHtml;

            if(listContainer) {
                listContainer.querySelectorAll('.join-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        promptPassword(e.target.dataset.rid, 'join');
                    });
                });
            }

            document.getElementById("search-btn").onclick = async () => {
                const val = document.getElementById("search-input").value.trim().toLowerCase();
                if(!val) return;
                
                const snap = await getDoc(doc(db, ROOM_COLLECTION, val));
                
                if(snap.exists()) {
                    promptPassword(val, 'join');
                } else {
                    promptPassword(val, 'create');
                }
            };
            
            document.getElementById("delete-all-rooms-btn").addEventListener('click', deleteAllRooms);
        }

        // --- Card Search Modal Logic ---
        document.getElementById('modal-close-btn').addEventListener('click', () => {
            document.getElementById('card-search-modal').style.display = 'none';
        });
        
        document.getElementById('modal-search-btn').addEventListener('click', async () => {
            const cardName = document.getElementById('modal-card-name').value.trim();
            const resultsDiv = document.getElementById('search-results');
            resultsDiv.innerHTML = '<p style="color:#f0f0f0;">Searching...</p>';

            if (!cardName) {
                resultsDiv.innerHTML = '<p style="color:#f0f0f0;">Please enter a card name.</p>';
                return;
            }

            try {
                const response = await fetch(`${SCRYFALL_API}${encodeURIComponent(cardName)}`);
                const data = await response.json();

                if (response.ok) {
                    const imgUrl = data.image_uris?.normal || data.card_faces?.[0]?.image_uris?.normal;
                    if (imgUrl) {
                        resultsDiv.innerHTML = `
                            <h4 style="color:#f0f0f0;">${data.name}</h4>
                            <img src="${imgUrl}" alt="${data.name}">
                        `;
                    } else {
                        resultsDiv.innerHTML = '<p style="color:#f0f0f0;">Card found, but image unavailable.</p>';
                    }
                } else {
                    resultsDiv.innerHTML = `<p style="color:#f0f0f0;">Card not found. Check spelling.</p>`;
                }
            } catch (e) {
                resultsDiv.innerHTML = `<p style="color:#f0f0f0;">Error connecting to Scryfall.</p>`;
                console.error(e);
            }
        });

        // ----------------------------------------------------------------------
        // 6. INIT
        // ----------------------------------------------------------------------

        function checkURLParamsAndInitialize() {
            const params = new URLSearchParams(window.location.search);
            const idFromURL = params.get('roomID');

            if (idFromURL) {
                promptPassword(idFromURL, 'join');
            } else {
                renderSetupView();
            }
        }

        onAuthStateChanged(auth, user => {
            if(user) {
                userId = user.uid;
                checkURLParamsAndInitialize(); 
            } else {
                signInAnonymously(auth).catch(e => {
                    document.getElementById("status-message").textContent = "Auth Error: " + e.message;
                });
            }
        });

    </script>
</body>
</html>
