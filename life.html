<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>MTG Life Tracker</title>
    <style>
        /* --- DARK MODE BASE STYLES --- */
        :root {
            --bg: #1e1e1e;
            --card: #2c2c2c;
            --muted: #aaa;
            --text: #f0f0f0;
            --accent: #2980b9;
            --dark-border: #444;
            --input-bg: #383838;
        }

        html,body {
            height: 100%;
            margin: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: var(--bg);
            color: var(--text);
            position: relative;
            min-height: 100vh;
            box-sizing: border-box;
        }

        /* --- Top Navigation (persistent) --- */
        header.app-header {
            width: 100%;
            max-width: 900px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 18px;
            gap: 12px;
        }
        .brand {
            display:flex;
            flex-direction:column;
            gap:2px;
        }
        .brand .app-title {
            color: var(--text);
            margin: 0;
            font-size: 1.25rem;
            line-height: 1;
        }
        .brand .app-subtitle {
            color: var(--muted);
            margin: 0;
            font-size: 0.8rem;
            font-style: italic;
        }
        nav.site-nav {
            display:flex;
            gap:8px;
            align-items:center;
        }
        nav.site-nav button {
            background: transparent;
            color: var(--text);
            border: 1px solid transparent;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
        }
        nav.site-nav button.active {
            background: rgba(41,128,185,0.12);
            border-color: var(--accent);
        }

        /* --- Main container --- */
        #app-container {
            width: 100%;
            max-width: 900px;
            background-color: var(--card);
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            border-radius: 12px;
            position: relative;
            box-sizing: border-box;
        }

        /* --- General Styles --- */
        input, textarea, select {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid var(--dark-border);
            border-radius: 6px;
            box-sizing: border-box;
            background-color: var(--input-bg);
            color: var(--text);
            font-size: 1rem;
        }

        textarea { min-height: 120px; resize: vertical; }

        /* Remove platform-specific appearance and tap highlight (mobile) */
        input, button, textarea, select {
            -webkit-appearance: none;
            appearance: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Hard-disable all outlines and focus rings across browsers */
        *:focus,
        *:focus-visible,
        *:focus-within {
            outline: none !important;
            box-shadow: none !important;
            -webkit-box-shadow: none !important;
        }

        /* Keep borders dark on focus and prevent background shift */
        input:focus,
        button:focus,
        textarea:focus {
            border-color: var(--dark-border) !important;
            background-color: inherit !important;
        }

        /* Chrome/Safari autofill color reset to match dark theme */
        input:-webkit-autofill,
        input:-webkit-autofill:focus,
        input:-webkit-autofill:hover,
        textarea:-webkit-autofill,
        textarea:-webkit-autofill:focus {
            -webkit-box-shadow: 0 0 0 1000px var(--input-bg) inset !important;
            box-shadow: 0 0 0 1000px var(--input-bg) inset !important;
            -webkit-text-fill-color: var(--text) !important;
            caret-color: var(--text) !important;
            border: 1px solid var(--dark-border) !important;
        }

        /* Remove number input spinners */
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] { -moz-appearance: textfield; }

        button {
            cursor: pointer;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            transition: transform 0.08s, opacity 0.12s;
            padding: 10px 12px;
        }

        button:active,
        .tapped {
            transform: scale(0.96);
        }

        .btn-primary { background-color: #27ae60; color: white; }
        .btn-danger { background-color: #c0392b; color: white; }
        .btn-secondary { background-color: #555; color: white; }

        /* --- Player / Game styles (kept from original) --- */
        .player-counter {
            border: 1px solid var(--dark-border);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            background-color: #333;
        }
        .life-section { display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; }
        .life-input { font-size: 2.5em; font-weight:800; color:#e0e0e0; width:100px; padding:0; border:none; background:none; text-align:left; }
        .life-total { font-size:2.5em; font-weight:800; color:#e0e0e0; }
        .player-name-display { font-size:1.1em; font-weight:600; margin-bottom:5px; }
        .cmd-name { font-size:0.9em; color:#aaa; display:inline-block; cursor:pointer; }

        .damage-section { background-color:#3a3a3a; padding:10px; border-radius:6px; margin-top:10px; }
        .damage-row { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; padding-bottom:8px; border-bottom:1px solid var(--dark-border); }
        .damage-input { width:50px; padding:4px; text-align:center; font-weight:bold; font-size:1em; border:1px solid #555; background-color:#444; color:var(--text); }
        .damage-input.lethal { color:#ff5555; border-color:#ff5555; }

        /* Suggestions list */
        .suggestions-list {
            position: absolute;
            width: 100%;
            background-color: var(--input-bg);
            border: 1px solid var(--dark-border);
            border-top: none;
            max-height: 150px;
            overflow-y: auto;
            z-index: 100;
            border-radius: 0 0 6px 6px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            margin-top: -10px;
        }
        .suggestions-list:empty { display:none !important; border:none !important; box-shadow:none !important; margin-top:0 !important; }
        .suggestion-item { padding:8px 12px; cursor:pointer; color:var(--text); }
        .suggestion-item:hover { background-color: rgba(41,128,185,0.12); }

        /* Lobby card preview */
        #lobby-card-preview {
            position: fixed;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            width: 250px;
            border: 3px solid var(--accent);
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8);
            z-index: 999;
            display: none;
            background: #111;
        }
        #lobby-card-preview img { display:block; width:100%; border-radius:5px; }

        /* Chat */
        #chat-log { height:150px; overflow-y:auto; border:1px solid #555; padding:10px; margin-bottom:10px; border-radius:6px; background:#333; font-size:0.9em; }

        /* Small helpers */
        .muted { color: var(--muted); }
        .row { display:flex; gap:8px; align-items:center; }
        .col { display:flex; flex-direction:column; gap:8px; }

        /* Responsive */
        @media (max-width:720px) {
            #lobby-card-preview { display:none !important; }
            header.app-header { flex-direction:column; align-items:flex-start; gap:8px; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
</head>
<body>
    <!-- Persistent header with navigation -->
    <header class="app-header" role="banner">
        <div class="brand">
            <h1 class="app-title">Cardboard Bonfire</h1>
            <div class="app-subtitle">Life tracker for keeping life and bringing people together.</div>
        </div>

        <nav class="site-nav" role="navigation" aria-label="Main">
            <button id="nav-home" class="nav-btn">Home</button>
            <button id="nav-changes" class="nav-btn">Changes</button>
            <button id="nav-contact" class="nav-btn">Contact</button>
        </nav>
    </header>

    <main id="app-container" role="main"></main>

    <div id="lobby-card-preview" aria-hidden="true">
        <img id="preview-img" alt="Commander Preview">
    </div>

    <p id="status-message" class="muted">Initializing...</p>

    <!-- Card search modal (kept) -->
    <div id="card-search-modal" class="modal" style="display:none; align-items:center; justify-content:center;">
        <div class="modal-content" style="background:#333; color:var(--text); padding:20px; border-radius:8px; width:90%; max-width:400px;">
            <h3>Card Search (Scryfall)</h3>
            <input type="text" id="modal-card-name" placeholder="Enter card name" autocomplete="off">
            <div id="modal-suggestions-list" class="suggestions-list"></div>
            <button id="modal-search-btn" class="btn-primary">Search</button>
            <div id="search-results"></div>
            <button id="modal-close-btn" class="btn-danger">Close</button>
        </div>
    </div>

    <script type="module">
        // ----------------------------------------------------------------------
        // 1. CONFIGURATION
        // ----------------------------------------------------------------------
        const USER_FIREBASE_CONFIG = {
            apiKey: "AIzaSyA_mz_fVsph8VHfCEG__9sWg_ZvwYX5_6E",
            authDomain: "mtg-life-tool.firebaseapp.com",
            projectId: "mtg-life-tool",
            storageBucket: "mtg-life-tool.appspot.com",
            messagingSenderId: "36730058988",
            appId: "1:36730058988:web:757e2d9620593b4f65022a"
        };
        const SCRYFALL_API = "https://api.scryfall.com/cards/named?exact=";
        const SCRYFALL_AUTOCOMPLETE_API = "https://api.scryfall.com/cards/autocomplete?q=";
        const TIMEOUT_MINUTES = 25;
        const DELETE_ALL_PWD = "DeleteAllRooms";
        const AUTOCOMPLETE_DEBOUNCE_MS = 100;

        // ----------------------------------------------------------------------
        // 2. IMPORTS
        // ----------------------------------------------------------------------
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import {
            getFirestore, doc, setDoc, getDoc, onSnapshot, serverTimestamp,
            arrayUnion, deleteDoc, collection, getDocs, query, limit
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ----------------------------------------------------------------------
        // 3. GLOBALS
        // ----------------------------------------------------------------------
        const app = initializeApp(USER_FIREBASE_CONFIG);
        const auth = getAuth(app);
        const db = getFirestore(app);

        let userId = null;
        let roomId = null;
        let unsubscribe = null;
        let autocompleteTimeout = null;
        const ROOM_COLLECTION = "mtg_rooms";

        // ----------------------------------------------------------------------
        // 4. HELPERS
        // ----------------------------------------------------------------------
        function hashPassword(password) {
            return CryptoJS.SHA256(password).toString(CryptoJS.enc.Hex);
        }

        async function checkAndDeleteIfExpired(id, roomData) {
            const lastActive = roomData.lastActive?.toDate?.();
            if (lastActive) {
                const elapsed = (new Date() - lastActive) / (1000 * 60);
                if (elapsed > TIMEOUT_MINUTES) {
                    try { await deleteDoc(doc(db, ROOM_COLLECTION, id)); } catch (e) {}
                    return true;
                }
            }
            return false;
        }

        function getStartingLife() { return 40; }

        async function validateCommander(name) {
            if (!name) return null;
            try {
                const response = await fetch(`${SCRYFALL_API}${encodeURIComponent(name)}`);
                const data = await response.json();
                if (response.ok) {
                    const imageUrl = data.image_uris?.normal || data.card_faces?.[0]?.image_uris?.normal;
                    if (imageUrl) return { validatedName: data.name, imageUrl };
                }
                return null;
            } catch (e) {
                console.error("Scryfall validation error:", e);
                return null;
            }
        }

        async function fetchAutocompleteSuggestions(query, listId, inputId) {
            const suggestionsList = document.getElementById(listId);
            const inputField = document.getElementById(inputId);
            if (!suggestionsList || !inputField) return;
            suggestionsList.innerHTML = '';
            if (query.length < 2) return;
            try {
                const response = await fetch(`${SCRYFALL_AUTOCOMPLETE_API}${encodeURIComponent(query)}`);
                const data = await response.json();
                if (response.ok && data.data && data.data.length > 0) {
                    data.data.slice(0, 5).forEach(suggestion => {
                        const item = document.createElement('div');
                        item.classList.add('suggestion-item');
                        item.textContent = suggestion;
                        item.onclick = () => {
                            inputField.value = suggestion;
                            suggestionsList.innerHTML = '';
                        };
                        suggestionsList.appendChild(item);
                    });
                }
            } catch (e) { console.error("Autocomplete error:", e); }
        }

        // ----------------------------------------------------------------------
        // 5. ROUTING & PAGES
        // ----------------------------------------------------------------------
        const navButtons = {
            home: document.getElementById('nav-home'),
            changes: document.getElementById('nav-changes'),
            contact: document.getElementById('nav-contact')
        };

        function setActiveNav(page) {
            Object.values(navButtons).forEach(btn => btn.classList.remove('active'));
            if (navButtons[page]) navButtons[page].classList.add('active');
        }

        function navigateTo(page) {
            // update hash without triggering reload
            if (location.hash !== `#${page}`) history.pushState(null, '', `#${page}`);
            setActiveNav(page);
            if (page === 'home') renderHome();
            else if (page === 'changes') renderChanges();
            else if (page === 'contact') renderContact();
        }

        // Attach nav listeners
        navButtons.home.addEventListener('click', () => navigateTo('home'));
        navButtons.changes.addEventListener('click', () => navigateTo('changes'));
        navButtons.contact.addEventListener('click', () => navigateTo('contact'));

        // On back/forward navigation
        window.addEventListener('popstate', () => {
            const page = (location.hash || '#home').replace('#', '') || 'home';
            setActiveNav(page);
            if (page === 'home') renderHome();
            else if (page === 'changes') renderChanges();
            else if (page === 'contact') renderContact();
        });

        // --- Page: Home (keeps your existing setup view) ---
        async function renderHome() {
            // Reuse renderSetupView logic but expose as renderHome
            await renderSetupView();
        }

        // --- Page: Changes (simple changelog viewer) ---
        const CHANGELOG = [
            { version: "0.9.2", date: "2025-11-30", notes: "Fixed hover preview and removed stray focus outlines; improved suggestions styling." },
            { version: "0.9.0", date: "2025-10-12", notes: "Initial public beta: room creation, chat, commander validation via Scryfall." }
        ];

        function renderChanges() {
            const appContainer = document.getElementById('app-container');
            let html = `<h2 style="margin-top:0; color:var(--text);">Changes</h2>`;
            html += `<div style="display:flex; flex-direction:column; gap:12px;">`;
            CHANGELOG.forEach(entry => {
                html += `
                    <div style="background:#2b2b2b; padding:12px; border-radius:8px; border:1px solid var(--dark-border);">
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <div style="font-weight:700; color:var(--text);">${entry.version}</div>
                            <div class="muted">${entry.date}</div>
                        </div>
                        <div style="margin-top:8px; color:var(--text);">${entry.notes}</div>
                    </div>
                `;
            });
            html += `</div>`;
            appContainer.innerHTML = html;
        }

        // --- Page: Contact (stores message to Firestore and opens mailto fallback) ---
        function renderContact() {
            const appContainer = document.getElementById('app-container');
            appContainer.innerHTML = `
                <h2 style="margin-top:0; color:var(--text);">Contact</h2>
                <p class="muted">Send a message — it will be saved to the app database and you can also open your email client.</p>
                <div style="max-width:640px;">
                    <input type="text" id="contact-name" placeholder="Your name">
                    <input type="email" id="contact-email" placeholder="Your email (optional)">
                    <textarea id="contact-message" placeholder="Your message"></textarea>
                    <div class="row">
                        <button id="contact-send" class="btn-primary">Send Message</button>
                        <button id="contact-mailto" class="btn-secondary">Open Email Client</button>
                    </div>
                    <p id="contact-status" class="muted" style="margin-top:8px;"></p>
                </div>
            `;

            document.getElementById('contact-send').addEventListener('click', async () => {
                const name = document.getElementById('contact-name').value.trim();
                const email = document.getElementById('contact-email').value.trim();
                const message = document.getElementById('contact-message').value.trim();
                const status = document.getElementById('contact-status');

                if (!name || !message) {
                    status.textContent = "Please include your name and a message.";
                    return;
                }

                status.textContent = "Saving message...";
                try {
                    const contactsRef = collection(db, 'contacts');
                    // Use setDoc with generated id via serverTimestamp to avoid collisions
                    await setDoc(doc(contactsRef, `${Date.now()}_${Math.random().toString(36).slice(2,8)}`), {
                        name, email, message, createdAt: serverTimestamp()
                    });
                    status.textContent = "Message saved. Thank you!";
                    document.getElementById('contact-name').value = '';
                    document.getElementById('contact-email').value = '';
                    document.getElementById('contact-message').value = '';
                } catch (e) {
                    console.error("Contact save failed:", e);
                    status.textContent = "Failed to save message. You can open your email client instead.";
                }
            });

            document.getElementById('contact-mailto').addEventListener('click', () => {
                const subject = encodeURIComponent("Contact from MTG Life Tracker");
                const body = encodeURIComponent("Hi,\n\nI'd like to get in touch regarding...");
                window.location.href = `mailto:youremail@example.com?subject=${subject}&body=${body}`;
            });
        }

        // ----------------------------------------------------------------------
        // 6. EXISTING APP: Setup View, Room List, Room View, etc.
        //    (Mostly preserved from your original code; minor adjustments to integrate with pages)
        // ----------------------------------------------------------------------

        async function renderSetupView() {
            const appContainer = document.getElementById("app-container");
            const statusMessage = document.getElementById("status-message");
            roomId = null;

            // Hide preview card and modal when changing views
            const previewCard = document.getElementById('lobby-card-preview');
            const previewImg = document.getElementById('preview-img');
            previewCard.style.display = 'none';
            document.getElementById('card-search-modal').style.display = 'none';

            statusMessage.textContent = "Browse rooms or create a new one.";
            statusMessage.style.color = "#aaa";

            let listHtml = '<p style="color:var(--text);">Loading active rooms...</p>';
            appContainer.innerHTML = `
                <div style="display:flex; gap:12px; align-items:center; margin-bottom:12px;">
                    <div style="flex:1;">
                        <input type="text" id="search-input" placeholder="Enter Room ID to Create/Search">
                    </div>
                    <div style="width:160px;">
                        <button id="search-btn" class="btn-primary" style="width:100%;">Find or Create Room</button>
                    </div>
                </div>
                <h3 style="color:var(--text); margin-top:0;">Active Rooms</h3>
                <div id="room-list-container">${listHtml}</div>
                <div style="margin-top:12px;">
                    <button id="delete-all-rooms-btn" class="btn-danger">Delete All Rooms (Admin)</button>
                </div>
            `;

            try {
                const q = query(collection(db, ROOM_COLLECTION), limit(15));
                const snap = await getDocs(q);
                if (snap.empty) {
                    listHtml = '<p style="color:var(--text);">No active rooms. Create one above!</p>';
                } else {
                    listHtml = '';
                    snap.forEach(docSnap => {
                        const rData = docSnap.data();
                        const rId = docSnap.id;
                        const pCount = Object.keys(rData.players || {}).length;
                        const ownerPlayer = rData.players[rData.ownerId];
                        const ownerCmdName = ownerPlayer?.commanderName || ownerPlayer?.commander || 'N/A';
                        const ownerCmdImage = ownerPlayer?.commanderImageUrl || '';
                        const ownerName = ownerPlayer?.name || 'Owner';

                        listHtml += `
                            <div class="room-item" style="display:flex; justify-content:space-between; align-items:center; background-color:#383838; padding: 10px; margin-bottom: 8px; border-radius: 4px;">
                                <div class="room-info">
                                    <span class="room-id" style="font-weight:bold; color:var(--text);">${rId}</span>
                                    <div style="font-size:0.9em; color:var(--muted); margin-top:4px;">
                                        ${pCount} Player(s) | Owner: ${ownerName}
                                        <span class="lobby-cmd-name" data-img-url="${ownerCmdImage}" style="cursor:help; margin-left:6px;">[${ownerCmdName}]</span>
                                    </div>
                                </div>
                                <div>
                                    <button class="join-btn btn-secondary" data-rid="${rId}" style="width:auto;">Join</button>
                                </div>
                            </div>
                        `;
                    });
                }
            } catch (e) {
                console.error("List error:", e);
                listHtml = `<p style="color:#ff5555;">Error loading rooms. Permissions might be initializing...</p>`;
            }

            const listContainer = document.getElementById("room-list-container");
            if (listContainer) listContainer.innerHTML = listHtml;

            // Attach listeners
            if (listContainer) {
                listContainer.querySelectorAll('.join-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        promptPassword(e.target.dataset.rid, 'join');
                    });
                });

                const previewCardEl = document.getElementById('lobby-card-preview');
                const previewImgEl = document.getElementById('preview-img');

                listContainer.querySelectorAll('.lobby-cmd-name').forEach(cmdSpan => {
                    const imageUrl = cmdSpan.dataset.imgUrl;
                    cmdSpan.addEventListener('mouseenter', () => {
                        if (imageUrl && previewCardEl && previewImgEl) {
                            previewImgEl.src = imageUrl;
                            previewCardEl.style.display = 'block';
                        }
                    });
                    cmdSpan.addEventListener('mouseleave', () => {
                        if (previewCardEl) {
                            previewCardEl.style.display = 'none';
                            previewImgEl.src = '';
                        }
                    });
                });
            }

            document.getElementById("search-btn").onclick = async () => {
                const val = document.getElementById("search-input").value.trim().toLowerCase();
                if (!val) return;
                const snap = await getDoc(doc(db, ROOM_COLLECTION, val));
                if (snap.exists()) promptPassword(val, 'join');
                else promptPassword(val, 'create');
            };

            document.getElementById("delete-all-rooms-btn").addEventListener('click', deleteAllRooms);
        }

        // --- Room view rendering (kept) ---
        function renderChat(chatLog, playerName) {
            const chatLogDiv = document.getElementById('chat-log');
            if (!chatLogDiv) return;
            chatLogDiv.innerHTML = '';
            const displayLog = (chatLog || []).slice(-20);
            displayLog.forEach(msg => {
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('chat-message');
                const senderSpan = document.createElement('span');
                senderSpan.classList.add('chat-sender');
                senderSpan.textContent = `${msg.senderName}:`;
                if (msg.senderName === playerName) senderSpan.style.color = '#74b9ff';
                messageDiv.appendChild(senderSpan);
                messageDiv.appendChild(document.createTextNode(msg.message));
                chatLogDiv.appendChild(messageDiv);
            });
            chatLogDiv.scrollTop = chatLogDiv.scrollHeight;
        }

        function renderRoomView(roomData) {
            const appContainer = document.getElementById("app-container");
            const statusMessage = document.getElementById("status-message");
            document.getElementById('lobby-card-preview').style.display = 'none';
            document.getElementById('card-search-modal').style.display = 'none';

            const currentPlayerName = roomData.players[userId]?.name || 'You';
            statusMessage.innerHTML = `Connected as: <strong>${currentPlayerName}</strong>`;

            let html = `
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px;">
                    <h2 style="margin:0; color:var(--text);">Room: ${roomId}</h2>
                    <div style="display:flex; gap:10px;">
                        <button id="delete-room-btn" class="btn-danger" style="width:auto; padding: 5px 10px;">Delete Room</button>
                        <button id="refresh-btn" class="btn-secondary" style="width:auto; padding: 5px 10px;">↻</button>
                    </div>
                </div>
            `;

            const playerIds = Object.keys(roomData.players);
            playerIds.sort((a, b) => (a === userId ? -1 : b === userId ? 1 : 0));
            html += `<h3 style="margin-top:0; color:var(--text);">Players</h3>`;

            playerIds.forEach(playerId => {
                const player = roomData.players[playerId];
                const isMe = playerId === userId;
                let lifeControls = '';
                let lifeDisplayHtml = '';
                if (isMe) {
                    lifeDisplayHtml = `<input type="number" value="${player.life}" class="life-input" onchange="updateLifeDirectly(this.value)">`;
                    lifeControls = `
                        <div class="control-group">
                            <button class="btn-life" data-type="life" data-val="-1">-1</button>
                            <button class="btn-life" data-type="life" data-val="-5">-5</button>
                            <button class="btn-life" data-type="life" data-val="+1">+1</button>
                            <button class="btn-life" data-type="life" data-val="+5">+5</button>
                        </div>
                    `;
                } else {
                    lifeDisplayHtml = `<span class="life-total">${player.life}</span>`;
                }

                const commanderName = player.commanderName || player.commander || 'N/A';
                const commanderImage = player.commanderImageUrl || '';

                const commanderHtml = `
                    <div class="cmd-name" id="cmd-name-${playerId}">
                        [${commanderName}]
                    </div>
                `;

                let damageRows = '';
                const opponents = playerIds.filter(id => id !== playerId);
                if (opponents.length > 0) {
                    damageRows = `<div class="damage-section"><h4 style="margin:0 0 10px 0; font-size:0.9em; color:var(--muted);">Commander Damage Taken</h4>`;
                    opponents.forEach(oppId => {
                        const opp = roomData.players[oppId];
                        const dmg = player.commanderDamage?.[oppId] || 0;
                        const isLethal = dmg >= 21;
                        let dmgControls = '';
                        if (isMe) {
                            dmgControls = `
                                <div class="control-group">
                                    <button class="btn-damage" data-opp="${oppId}" data-val="-1">-</button>
                                    <button class="btn-damage" data-opp="${oppId}" data-val="+1">+</button>
                                </div>
                            `;
                        }
                        const oppCmdName = opp.commanderName || opp.commander || 'N/A';
                        damageRows += `
                            <div class="damage-row">
                                <span style="font-size:0.9em;">From <strong>${opp.name}</strong> [${oppCmdName}]</span>
                                <div style="display:flex; align-items:center; gap:10px;">
                                    <input type="number" min="0" value="${dmg}" data-opp="${oppId}" class="damage-input ${isLethal ? 'lethal' : ''}" onchange="updateCmdDamageDirectly(this.dataset.opp, this.value)" style="width:50px;">
                                    ${dmgControls}
                                </div>
                            </div>
                        `;
                    });
                    damageRows += `</div>`;
                }

                html += `
                    <div class="player-counter" style="${isMe ? 'border: 2px solid var(--accent);' : ''}">
                        <div class="life-section">
                            <div class="life-display">
                                <div class="player-name-display">${isMe ? 'YOU' : player.name}</div>
                                ${commanderHtml}
                                ${lifeDisplayHtml}
                            </div>
                            ${lifeControls}
                        </div>
                        ${damageRows}
                    </div>
                `;
            });

            html += `
                <div id="chat-container">
                    <h3 style="margin-bottom:10px; color:var(--text);">Game Chat</h3>
                    <div id="chat-log"></div>
                    <form id="chat-input-form" style="display:flex; gap:8px;">
                        <input type="text" id="chat-message-input" placeholder="Type message..." maxlength="150" required>
                        <button type="submit" class="btn-primary">Send</button>
                    </form>
                </div>
            `;

            html += `
                <div id="lobby-features" style="margin-top:12px;">
                    <h3 style="width:100%; margin-bottom:8px; color:var(--text);">Game Tools</h3>
                    <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
                        <button id="roll-dice-btn" class="btn-secondary">Roll D20</button>
                        <div id="roll-result" style="width:40%; text-align:center; color:var(--text); font-weight:700;">-</div>
                    </div>
                    <div style="display:flex; gap:8px; flex-wrap:wrap;">
                        <button id="turn-order-btn" class="btn-secondary">Determine Turn Order</button>
                        <button id="card-search-btn" class="btn-secondary">Card Search</button>
                        <button id="share-invite-btn" class="btn-secondary">Share Invite Link</button>
                    </div>
                </div>
                <div style="margin-top:12px;">
                    <button id="leave-room-btn" class="btn-danger">Leave Room</button>
                </div>
            `;

            appContainer.innerHTML = html;

            // render chat
            renderChat(roomData.chatLog || [], currentPlayerName);

            // attach listeners (life/damage/chat etc.)
            document.querySelectorAll('.btn-life').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.target.classList.add('tapped');
                    setTimeout(() => e.target.classList.remove('tapped'), 100);
                    updateLife(parseInt(e.target.dataset.val));
                });
            });

            document.querySelectorAll('.btn-damage').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.target.classList.add('tapped');
                    setTimeout(() => e.target.classList.remove('tapped'), 100);
                    updateCmdDamage(e.target.dataset.opp, parseInt(e.target.dataset.val));
                });
            });

            document.getElementById('chat-input-form').addEventListener('submit', (e) => {
                e.preventDefault();
                const input = document.getElementById('chat-message-input');
                const message = input.value.trim();
                if (message) {
                    sendChatMessage(message, currentPlayerName);
                    input.value = '';
                }
            });

            document.getElementById('share-invite-btn').addEventListener('click', () => {
                const roomUrl = `${window.location.origin}${window.location.pathname}?roomID=${roomId}`;
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(roomUrl).then(() => alert(`Invite link copied to clipboard: ${roomUrl}`)).catch(err => console.error(err));
                } else {
                    prompt(`Invite link (Copy Manually):`, roomUrl);
                }
            });

            document.getElementById('leave-room-btn').addEventListener('click', () => {
                if (unsubscribe) unsubscribe();
                roomId = null;
                window.history.pushState({}, document.title, window.location.pathname);
                navigateTo('home');
            });

            document.getElementById('refresh-btn').addEventListener('click', () => {
                if (roomId) listenToRoom(roomId);
            });

            document.getElementById('delete-room-btn').addEventListener('click', () => {
                if (confirm("Are you sure you want to delete this room for ALL players?")) deleteRoom(roomId);
            });

            document.getElementById('roll-dice-btn').addEventListener('click', () => {
                const roll = Math.floor(Math.random() * 20) + 1;
                document.getElementById('roll-result').textContent = roll;
            });

            document.getElementById('turn-order-btn').addEventListener('click', () => determineTurnOrder(roomData.players));

            document.getElementById('card-search-btn').addEventListener('click', () => {
                document.getElementById('card-search-modal').style.display = 'flex';
                document.getElementById('modal-card-name').value = '';
                document.getElementById('search-results').innerHTML = '';
            });

            // commander hover preview
            const previewCard = document.getElementById('lobby-card-preview');
            const previewImg = document.getElementById('preview-img');
            playerIds.forEach(playerId => {
                const cmdElement = document.getElementById(`cmd-name-${playerId}`);
                if (cmdElement) {
                    const imgUrl = roomData.players[playerId].commanderImageUrl;
                    cmdElement.addEventListener('mouseenter', () => {
                        if (imgUrl && previewCard && previewImg) {
                            previewImg.src = imgUrl;
                            previewCard.style.display = 'block';
                        }
                    });
                    cmdElement.addEventListener('mouseleave', () => {
                        if (previewCard && previewImg) {
                            previewCard.style.display = 'none';
                            previewImg.src = '';
                        }
                    });
                }
            });

            // expose direct update helpers globally
            window.updateCmdDamageDirectly = updateCmdDamageDirectly;
            window.updateLifeDirectly = updateLifeDirectly;
        }

        // --- Chat & data helpers (kept) ---
        async function sendChatMessage(message, senderName) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);
            const chatMessage = { senderId: userId, senderName, message, timestamp: Date.now() };
            try {
                await setDoc(ref, { chatLog: arrayUnion(chatMessage), lastActive: serverTimestamp() }, { merge: true });
            } catch (e) { console.error("Error sending chat message:", e); }
        }

        async function updateLifeDirectly(newValue) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);
            const newLife = parseInt(newValue) || 0;
            try {
                const snap = await getDoc(ref);
                if (!snap.exists()) return;
                await setDoc(ref, { players: { [userId]: { life: newLife } }, lastActive: serverTimestamp() }, { merge: true });
            } catch (e) { console.error("Error setting life total directly:", e); }
        }

        async function updateLife(delta) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);
            try {
                const snap = await getDoc(ref);
                if (snap.exists()) {
                    const data = snap.data();
                    const cur = data.players[userId]?.life ?? getStartingLife();
                    await updateLifeDirectly(cur + delta);
                }
            } catch (e) { console.error(e); }
        }

        async function updateCmdDamage(oppId, delta) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);
            try {
                const snap = await getDoc(ref);
                if (snap.exists()) {
                    const data = snap.data();
                    const currentPlayer = data.players[userId];
                    if (!currentPlayer) return;
                    const currentDamageMap = currentPlayer.commanderDamage || {};
                    const currentDamage = currentDamageMap[oppId] || 0;
                    const newDamage = Math.max(0, currentDamage + delta);
                    await updateCmdDamageDirectly(oppId, newDamage);
                }
            } catch (e) { console.error("Error updating commander damage:", e); }
        }

        async function updateCmdDamageDirectly(oppId, newValue) {
            if (!roomId || !userId) return;
            const ref = doc(db, ROOM_COLLECTION, roomId);
            const newDamage = Math.max(0, parseInt(newValue) || 0);
            try {
                const snap = await getDoc(ref);
                if (!snap.exists()) return;
                const data = snap.data();
                const currentPlayer = data.players[userId];
                if (!currentPlayer) return;
                const currentDamageMap = currentPlayer.commanderDamage || {};
                currentDamageMap[oppId] = newDamage;
                await setDoc(ref, {
                    players: {
                        [userId]: {
                            ...currentPlayer,
                            commanderDamage: currentDamageMap
                        }
                    },
                    lastActive: serverTimestamp()
                }, { merge: true });
            } catch (e) { console.error("Error setting commander damage directly:", e); }
        }

        // --- Room creation / join flows (kept) ---
        function promptPassword(rid, mode) {
            const appContainer = document.getElementById("app-container");
            const title = mode === 'join' ? `Join Room: ${rid}` : `Create Room: ${rid}`;
            const btnText = mode === 'join' ? "Enter Game" : "Create Room";
            document.getElementById('lobby-card-preview').style.display = 'none';
            document.getElementById('card-search-modal').style.display = 'none';

            appContainer.innerHTML = `
                <h2 style="color:var(--text); margin-top:0;">${title}</h2>
                <input type="text" id="player-name-input" placeholder="Your Player Name">
                <div style="position:relative;">
                    <input type="text" id="commander-input" placeholder="Your Commander's Name (Required)" autocomplete="off">
                    <div id="suggestions-list" class="suggestions-list"></div>
                </div>
                <input type="password" id="pwd-input" placeholder="Room Password">
                <div style="display:flex; gap:8px; margin-top:8px;">
                    <button id="action-btn" class="btn-primary">${btnText}</button>
                    <button id="cancel-btn" class="btn-danger">Cancel</button>
                </div>
                <p id="err-msg" style="color:#ff5555;"></p>
            `;

            const commanderInput = document.getElementById('commander-input');
            const suggestionsList = document.getElementById('suggestions-list');

            commanderInput.addEventListener('input', () => {
                const query = commanderInput.value.trim();
                if (autocompleteTimeout) clearTimeout(autocompleteTimeout);
                if (query.length >= 2) {
                    autocompleteTimeout = setTimeout(() => fetchAutocompleteSuggestions(query, 'suggestions-list', 'commander-input'), AUTOCOMPLETE_DEBOUNCE_MS);
                } else suggestionsList.innerHTML = '';
            });

            document.addEventListener('click', (e) => {
                if (suggestionsList && !commanderInput.contains(e.target) && !suggestionsList.contains(e.target)) suggestionsList.innerHTML = '';
            });

            document.getElementById("cancel-btn").onclick = () => {
                window.history.pushState({}, document.title, window.location.pathname);
                navigateTo('home');
            };

            document.getElementById("action-btn").onclick = async () => {
                const name = document.getElementById("player-name-input").value.trim();
                const commander = document.getElementById("commander-input").value.trim();
                const pwd = document.getElementById("pwd-input").value;
                const errMsg = document.getElementById("err-msg");
                if (!name || !pwd || !commander) { errMsg.textContent = "Player Name, Commander, and Password are required."; return; }
                errMsg.textContent = "Verifying commander and joining...";
                document.getElementById("action-btn").disabled = true;
                const validationResult = await validateCommander(commander);
                if (!validationResult) {
                    errMsg.textContent = `Commander "${commander}" not found on Scryfall. Please check spelling or use the Card Search tool.`;
                    document.getElementById("action-btn").disabled = false;
                    return;
                }
                const { validatedName, imageUrl } = validationResult;
                if (mode === 'join') {
                    const ref = doc(db, ROOM_COLLECTION, rid);
                    const snap = await getDoc(ref);
                    if (snap.exists()) {
                        const data = snap.data();
                        if (await checkAndDeleteIfExpired(rid, data)) {
                            errMsg.textContent = "Room expired and was deleted.";
                            setTimeout(() => navigateTo('home'), 2000);
                            return;
                        }
                        if (data.passwordHash === hashPassword(pwd)) {
                            listenToRoom(rid, name, validatedName, imageUrl);
                        } else {
                            errMsg.textContent = "Wrong password.";
                            document.getElementById("action-btn").disabled = false;
                        }
                    } else {
                        errMsg.textContent = "Room no longer exists.";
                        document.getElementById("action-btn").disabled = false;
                    }
                } else {
                    if (pwd.length < 3) {
                        errMsg.textContent = "Password too short.";
                        document.getElementById("action-btn").disabled = false;
                        return;
                    }
                    createRoom(rid, pwd, name, validatedName, imageUrl);
                }
            };
        }

        async function createRoom(rid, pwd, name, commanderName, commanderImageUrl) {
            if (!userId) return;
            const ref = doc(db, ROOM_COLLECTION, rid);
            try {
                await setDoc(ref, {
                    ownerId: userId,
                    passwordHash: hashPassword(pwd),
                    createdAt: serverTimestamp(),
                    lastActive: serverTimestamp(),
                    chatLog: [],
                    players: {
                        [userId]: {
                            life: getStartingLife(),
                            commanderDamage: {},
                            name,
                            commanderName,
                            commanderImageUrl
                        }
                    }
                });
                listenToRoom(rid);
            } catch (e) { console.error(e); }
        }

        function listenToRoom(rid, newName = null, newCommanderName = null, newCommanderImageUrl = null) {
            if (unsubscribe) unsubscribe();
            const ref = doc(db, ROOM_COLLECTION, rid);
            unsubscribe = onSnapshot(ref, (snap) => {
                if (snap.exists()) {
                    roomId = rid;
                    const data = snap.data();
                    if (!data.players[userId]) {
                        if (newName && newCommanderName && newCommanderImageUrl) {
                            setDoc(ref, {
                                players: {
                                    [userId]: {
                                        life: getStartingLife(),
                                        commanderDamage: {},
                                        name: newName,
                                        commanderName: newCommanderName,
                                        commanderImageUrl: newCommanderImageUrl
                                    }
                                },
                                lastActive: serverTimestamp()
                            }, { merge: true });
                        } else {
                            renderSetupView();
                            return;
                        }
                    }
                    renderRoomView(data);
                } else {
                    renderSetupView();
                }
            });
        }

        // --- Admin / misc helpers ---
        async function deleteAllRooms() {
            const password = prompt("Enter the global deletion password to confirm this action:");
            if (password !== DELETE_ALL_PWD) { alert("Incorrect password. All rooms were NOT deleted."); return; }
            if (!confirm("LAST WARNING: Are you absolutely sure you want to delete ALL rooms? This cannot be undone.")) return;
            document.getElementById("status-message").textContent = "Deleting all rooms...";
            const roomsRef = collection(db, ROOM_COLLECTION);
            try {
                const snapshot = await getDocs(roomsRef);
                let deleteCount = 0;
                for (const docSnapshot of snapshot.docs) {
                    await deleteDoc(doc(db, ROOM_COLLECTION, docSnapshot.id));
                    deleteCount++;
                }
                alert(`Success! Deleted ${deleteCount} room(s).`);
                renderSetupView();
            } catch (e) {
                console.error("Failed to delete all rooms:", e);
                alert("An error occurred during bulk deletion. Check the console.");
            }
        }

        function determineTurnOrder(players) {
            const playerNames = Object.values(players).map(p => p.name || 'Unknown Player');
            if (playerNames.length < 2) { alert("Need at least two players to determine turn order."); return; }
            for (let i = playerNames.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [playerNames[i], playerNames[j]] = [playerNames[j], playerNames[i]];
            }
            const orderText = `Turn Order:\n1. ${playerNames[0]}\n2. ${playerNames[1]}${playerNames[2] ? `\n3. ${playerNames[2]}` : ''}\n...`;
            alert(orderText);
        }

        async function deleteRoom(id) {
            if (!id) return;
            try {
                await deleteDoc(doc(db, ROOM_COLLECTION, id));
                if (unsubscribe) unsubscribe();
                roomId = null;
                renderSetupView();
            } catch (e) {
                alert("Failed to delete room. Check console for details.");
                console.error("Delete room failed:", e);
            }
        }

        // ----------------------------------------------------------------------
        // 7. Modal & autocomplete wiring (kept)
        // ----------------------------------------------------------------------
        const modalCardNameInput = document.getElementById('modal-card-name');
        const modalSuggestionsList = document.getElementById('modal-suggestions-list');
        let modalAutocompleteTimeout = null;

        document.getElementById('modal-close-btn').addEventListener('click', () => {
            document.getElementById('card-search-modal').style.display = 'none';
        });

        modalCardNameInput.addEventListener('input', () => {
            const query = modalCardNameInput.value.trim();
            if (modalAutocompleteTimeout) clearTimeout(modalAutocompleteTimeout);
            if (query.length >= 2) {
                modalAutocompleteTimeout = setTimeout(() => fetchAutocompleteSuggestions(query, 'modal-suggestions-list', 'modal-card-name'), AUTOCOMPLETE_DEBOUNCE_MS);
            } else modalSuggestionsList.innerHTML = '';
        });

        document.getElementById('modal-search-btn').addEventListener('click', () => {
            modalSuggestionsList.innerHTML = '';
            const cardName = modalCardNameInput.value.trim();
            const resultsDiv = document.getElementById('search-results');
            resultsDiv.innerHTML = '<p style="color:var(--text);">Searching...</p>';
            if (!cardName) { resultsDiv.innerHTML = '<p style="color:var(--text);">Please enter a card name.</p>'; return; }
            validateCommander(cardName).then(result => {
                if (result) {
                    resultsDiv.innerHTML = `<h4 style="color:var(--text);">${result.validatedName}</h4><img src="${result.imageUrl}" alt="${result.validatedName}">`;
                } else {
                    resultsDiv.innerHTML = `<p style="color:var(--text);">Card not found. Check spelling.</p>`;
                }
            }).catch(e => {
                resultsDiv.innerHTML = `<p style="color:var(--text);">Error connecting to Scryfall.</p>`;
                console.error(e);
            });
        });

        // ----------------------------------------------------------------------
        // 8. INIT: Auth + initial route
        // ----------------------------------------------------------------------
        function initialRoute() {
            // If URL has roomID param, open join flow; otherwise route by hash
            const params = new URLSearchParams(window.location.search);
            const idFromURL = params.get('roomID');
            if (idFromURL) {
                promptPassword(idFromURL, 'join');
                setActiveNav('home');
                return;
            }
            const page = (location.hash || '#home').replace('#', '') || 'home';
            setActiveNav(page);
            if (page === 'home') renderHome();
            else if (page === 'changes') renderChanges();
            else if (page === 'contact') renderContact();
        }

        onAuthStateChanged(auth, user => {
            if (user) {
                userId = user.uid;
                initialRoute();
            } else {
                signInAnonymously(auth).catch(e => {
                    document.getElementById("status-message").textContent = "Auth Error: " + e.message;
                });
            }
        });

    </script>
</body>
</html>
