<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MTG Life Tracker</title>
  <style>
    :root{
      --bg:#0f1113;--card:#16181a;--muted:#9aa3ad;--text:#e6eef6;
      --accent:#2980b9;--accent-strong:#1f6fa8;--green:#27ae60;--red:#c0392b;
      --dark-border:#22272a;--input-bg:#1f2326;
    }
    html,body{height:100%;margin:0}
    body{
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background:var(--bg);color:var(--text);display:flex;flex-direction:column;
      align-items:center;padding:20px;box-sizing:border-box;min-height:100vh;
    }
    header.app-header{width:100%;max-width:1100px;display:flex;justify-content:space-between;align-items:center;margin-bottom:18px;gap:12px}
    .brand{display:flex;flex-direction:column;gap:2px}
    .app-title{margin:0;font-size:1.25rem;color:var(--text)}
    .app-subtitle{margin:0;font-size:0.8rem;color:var(--muted);font-style:italic}
    nav.site-nav{display:flex;gap:8px}
    nav.site-nav button{background:transparent;color:var(--text);border:1px solid transparent;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
    nav.site-nav button.active{background:rgba(41,128,185,0.10);border-color:var(--accent)}
    #app-container{width:100%;max-width:1100px;background:var(--card);padding:20px;border-radius:12px;box-shadow:0 6px 30px rgba(0,0,0,0.6);box-sizing:border-box;position:relative}
    input,textarea,select{width:100%;padding:12px;margin-bottom:10px;border-radius:8px;border:1px solid var(--dark-border);background:var(--input-bg);color:var(--text);box-sizing:border-box}
    textarea{min-height:120px;resize:vertical}
    input,button,textarea,select{-webkit-appearance:none;appearance:none;-webkit-tap-highlight-color:transparent}
    *:focus,*:focus-visible,*:focus-within{outline:none!important;box-shadow:none!important}
    button{cursor:pointer;border-radius:8px;padding:10px 12px;border:none;font-weight:700;transition:transform .08s ease,opacity .12s}
    button:active,.tapped{transform:scale(.96)}
    .btn-primary{background:linear-gradient(180deg,var(--green),#1f8a4a);color:#fff}
    .btn-danger{background:linear-gradient(180deg,var(--red),#9b2b24);color:#fff}
    .btn-secondary{background:linear-gradient(180deg,#3a3a3a,#2f2f2f);color:#fff}
    button:disabled, input:disabled { opacity: .45; cursor: not-allowed; filter: grayscale(.2); }
    .player-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:16px;margin-top:12px}
    @media(max-width:900px){.player-grid{grid-template-columns:1fr}}
    .player-panel{background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0.00));border:1px solid var(--dark-border);border-radius:12px;padding:14px;display:flex;flex-direction:column;gap:10px;position:relative;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
    .player-header{display:flex;justify-content:space-between;align-items:center;gap:8px}
    .player-name{font-weight:800;font-size:1rem;color:var(--text)}
    .player-sub{font-size:.85rem;color:var(--muted)}
    .life-big{font-size:3.2rem;font-weight:900;color:var(--text);letter-spacing:-1px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .control-btn{padding:8px 12px;border-radius:8px;font-weight:800;min-width:56px;text-align:center;background:linear-gradient(180deg,#2b2b2b,#232323);color:var(--text);border:1px solid rgba(255,255,255,0.03);cursor:pointer;display:inline-flex;align-items:center;justify-content:center}
    .control-btn.positive{background:linear-gradient(180deg,#2ecc71,#27ae60);color:#04260a}
    .control-btn.negative{background:linear-gradient(180deg,#ff6b6b,#c0392b);color:#2b0706}
    .cmd-block{display:flex;justify-content:space-between;align-items:center;gap:8px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    .cmd-label{font-size:.9rem;color:var(--muted)}
    .cmd-value{font-weight:800;color:#ffb3b3}
    .you-badge{background:linear-gradient(90deg,var(--accent),var(--accent-strong));color:#fff;padding:6px 8px;border-radius:999px;font-weight:800;font-size:.8rem}
    .cmd-controls{display:none;margin-top:10px}
    .cmd-controls.open{display:block}
    .per-opp-container{margin-top:10px;display:flex;flex-direction:column;gap:6px;max-height:160px;overflow:auto;border-top:1px solid rgba(255,255,255,0.02);padding-top:8px}
    .per-opp-row{height:44px;display:flex;justify-content:space-between;align-items:center;gap:8px;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02);box-sizing:border-box}
    .per-opp-left{font-size:0.9em;color:var(--muted);font-weight:700}
    .per-opp-controls{display:flex;align-items:center;gap:8px}
    .outgoing-cmd-list{display:flex;flex-direction:column;gap:6px;margin-top:8px}
    .outgoing-cmd-item{font-size:0.95rem;color:var(--text);display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
    .infect-block{margin-top:8px;display:flex;align-items:center;gap:8px}
    .infect-label{font-size:0.85rem;color:var(--muted)}
    .infect-value{font-weight:800;color:#bfe6a8;min-width:36px;text-align:center}
    .small-btn{padding:6px 8px;font-size:0.85rem;min-width:36px;border-radius:6px}
    #chat-log{height:150px;overflow-y:auto;border:1px solid rgba(255,255,255,0.03);padding:10px;margin-bottom:10px;border-radius:8px;background:#0f1113;font-size:.9em}
    .chat-message{margin-bottom:6px;display:flex;gap:8px;align-items:center}
    .chat-sender{font-weight:800;color:#74b9ff;margin-right:6px}
    .chat-sender.system{color:#ffd166;font-weight:900}
    .chat-card{display:inline-block;position:relative;cursor:pointer;color:var(--text);text-decoration:underline dotted rgba(255,255,255,0.08)}
    #chat-card-preview{position:fixed;top:50%;right:20px;transform:translateY(-50%);width:300px;max-width:40vw;border:3px solid var(--accent);border-radius:10px;box-shadow:0 12px 40px rgba(0,0,0,0.7);background:#0b0d0f;z-index:1500;display:none;padding:8px}
    #chat-card-preview img{display:block;width:100%;border-radius:6px}
    #chat-card-preview .card-title{margin-top:8px;font-weight:800;color:var(--text);text-align:center}
    .modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.6);display:none;justify-content:center;align-items:center;z-index:2000}
    .modal-content{background:#16181a;color:var(--text);padding:20px;border-radius:10px;width:92%;max-width:520px;box-shadow:0 12px 40px rgba(0,0,0,0.7);position:relative}
    .suggestions-list{position:absolute;width:100%;background:var(--input-bg);border:1px solid var(--dark-border);border-top:none;max-height:150px;overflow-y:auto;z-index:100;border-radius:0 0 8px 8px;box-shadow:0 6px 18px rgba(0,0,0,0.6);margin-top:-10px}
    .suggestions-list:empty{display:none!important;border:none!important;box-shadow:none!important;margin-top:0!important}
    .suggestion-item{padding:8px 12px;cursor:pointer;color:var(--text)}
    .suggestion-item:hover{background:rgba(41,128,185,.08)}
    #lobby-card-preview{position:fixed;top:50%;left:20px;transform:translateY(-50%);width:260px;border:3px solid var(--accent);border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.8);z-index:999;display:none;background:#0b0d0f}
    #lobby-card-preview img{display:block;width:100%;border-radius:6px}
    #lobby-features{margin-top:18px;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    #room-footer{margin-top:14px;color:var(--muted);font-size:.9rem;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .muted{color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
    .col{display:flex;flex-direction:column;gap:8px}
    @media(max-width:720px){header.app-header{flex-direction:column;align-items:flex-start;gap:8px}#lobby-card-preview{display:none!important}#chat-card-preview{display:none!important}}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
</head>
<body>
  <header class="app-header" role="banner">
    <div class="brand">
      <h1 class="app-title">Cardboard Bonfire</h1>
      <div class="app-subtitle">Life tracker for keeping life and bringing people together.</div>
    </div>
    <nav class="site-nav" role="navigation" aria-label="Main">
      <button id="nav-home" class="nav-btn">Home</button>
      <button id="nav-changes" class="nav-btn">Changes</button>
      <button id="nav-contact" class="nav-btn">Contact</button>
    </nav>
  </header>

  <main id="app-container" role="main"></main>

  <div id="lobby-card-preview" aria-hidden="true"><img id="preview-img" alt="Commander Preview"></div>
  <div id="chat-card-preview" aria-hidden="true"><img id="chat-preview-img" alt="Card Preview"><div class="card-title" id="chat-preview-title"></div></div>
  <p id="status-message" class="muted">Initializing...</p>

  <div id="card-search-modal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <h3 style="margin-top:0">Card Search (Scryfall)</h3>
      <input type="text" id="modal-card-name" placeholder="Enter card name" autocomplete="off">
      <div id="modal-suggestions-list" class="suggestions-list"></div>
      <div style="display:flex;gap:8px;margin-top:10px;">
        <button id="modal-search-btn" class="btn-primary">Search & Post</button>
        <button id="modal-close-btn" class="btn-secondary">Close</button>
      </div>
      <div id="search-results" style="margin-top:12px"></div>
    </div>
  </div>

  <div id="edit-commander-modal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <h3 style="margin-top:0">Edit Commander</h3>
      <input type="text" id="edit-commander-name" placeholder="Commander name">
      <div id="edit-commander-suggestions" class="suggestions-list"></div>
      <div style="display:flex;gap:8px;margin-top:10px;">
        <button id="edit-commander-save" class="btn-primary">Save</button>
        <button id="edit-commander-cancel" class="btn-secondary">Cancel</button>
      </div>
      <div id="edit-commander-result" style="margin-top:12px"></div>
    </div>
  </div>

  <script type="module">
    // CONFIG
    const USER_FIREBASE_CONFIG = {
      apiKey: "AIzaSyA_mz_fVsph8VHfCEG__9sWg_ZvwYX5_6E",
      authDomain: "mtg-life-tool.firebaseapp.com",
      projectId: "mtg-life-tool",
      storageBucket: "mtg-life-tool.appspot.com",
      messagingSenderId: "36730058988",
      appId: "1:36730058988:web:757e2d9620593b4f65022a"
    };
    const SCRYFALL_API = "https://api.scryfall.com/cards/named?exact=";
    const SCRYFALL_AUTOCOMPLETE_API = "https://api.scryfall.com/cards/autocomplete?q=";
    const TIMEOUT_MINUTES = 20; // changed to 20 minutes per request
    const DELETE_ALL_PWD = "DeleteAllRooms";
    const AUTOCOMPLETE_DEBOUNCE_MS = 100;

    // IMPORTS
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, onSnapshot, serverTimestamp,
      arrayUnion, deleteDoc, collection, getDocs, query, limit, updateDoc
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // GLOBALS
    const app = initializeApp(USER_FIREBASE_CONFIG);
    const auth = getAuth(app);
    const db = getFirestore(app);

    let userId = null;
    let roomId = null;
    let unsubscribe = null;
    let autocompleteTimeout = null;
    const ROOM_COLLECTION = "mtg_rooms";
    const openCmdControls = new Set();

    function hashPassword(password){ return CryptoJS.SHA256(password).toString(CryptoJS.enc.Hex); }
    function getStartingLife(){ return 40; }

    async function validateCommander(name){
      if(!name) return null;
      try{
        const response = await fetch(`${SCRYFALL_API}${encodeURIComponent(name)}`);
        const data = await response.json();
        if(response.ok){
          const imageUrl = data.image_uris?.normal || data.card_faces?.[0]?.image_uris?.normal;
          if(imageUrl) return { validatedName: data.name, imageUrl };
        }
        return null;
      }catch(e){ console.error("Scryfall validation error:", e); return null; }
    }

    async function fetchAutocompleteSuggestions(query, listId, inputId){
      const suggestionsList = document.getElementById(listId);
      const inputField = document.getElementById(inputId);
      if(!suggestionsList || !inputField) return;
      suggestionsList.innerHTML = '';
      if(query.length < 2) return;
      try{
        const response = await fetch(`${SCRYFALL_AUTOCOMPLETE_API}${encodeURIComponent(query)}`);
        const data = await response.json();
        if(response.ok && data.data && data.data.length){
          data.data.slice(0,5).forEach(suggestion=>{
            const item = document.createElement('div');
            item.classList.add('suggestion-item');
            item.textContent = suggestion;
            item.onclick = () => { inputField.value = suggestion; suggestionsList.innerHTML = ''; };
            suggestionsList.appendChild(item);
          });
        }
      }catch(e){ console.error("Autocomplete error:", e); }
    }

    // compute outgoing map for a source player (what this player's commander has done to others)
    function computeOutgoingCmdDamage(roomData, sourcePlayerId){
      const players = roomData.players || {};
      const order = Array.isArray(roomData.playersOrder) && roomData.playersOrder.length ? roomData.playersOrder : Object.keys(players || {});
      const result = [];
      order.forEach(pid => {
        if(pid === sourcePlayerId) return;
        const dmg = (players[sourcePlayerId]?.commanderDamage || {})[pid] || 0;
        const name = players[pid]?.name || 'Player';
        result.push({ oppId: pid, oppName: name, dmg });
      });
      return result;
    }

    // compute outgoing total for a source player (sum of their commanderDamage map)
    function computeOutgoingTotal(roomData, sourcePlayerId){
      const dmgMap = (roomData.players?.[sourcePlayerId]?.commanderDamage) || {};
      return Object.keys(dmgMap).reduce((s,k)=> s + (parseInt(dmgMap[k])||0), 0);
    }

    // compute incoming total for a target player
    function computeIncomingCmdDamage(roomData, targetPlayerId){
      let total = 0;
      const players = roomData.players || {};
      Object.keys(players).forEach(pid=>{
        const dmgMap = players[pid]?.commanderDamage || {};
        const val = dmgMap[targetPlayerId] || 0;
        total += val;
      });
      return total;
    }

    // PERSISTENCE HELPERS (keep players in lobby after refresh)
    function persistJoinedRoom(rid, uid){
      try{
        localStorage.setItem('mtg_current_room', rid || '');
        localStorage.setItem('mtg_current_user', uid || '');
      }catch(e){ console.warn('localStorage not available', e); }
    }
    function clearPersistedRoom(){
      try{ localStorage.removeItem('mtg_current_room'); localStorage.removeItem('mtg_current_user'); }catch(e){}
    }
    function getPersistedRoom(){
      try{
        return { roomId: localStorage.getItem('mtg_current_room'), userId: localStorage.getItem('mtg_current_user') };
      }catch(e){ return { roomId: null, userId: null }; }
    }

    // ROUTING
    const navButtons = { home: document.getElementById('nav-home'), changes: document.getElementById('nav-changes'), contact: document.getElementById('nav-contact') };
    function setActiveNav(page){ Object.values(navButtons).forEach(b=>b.classList.remove('active')); if(navButtons[page]) navButtons[page].classList.add('active'); }
    function navigateTo(page){ if(location.hash !== `#${page}`) history.pushState(null,'',`#${page}`); setActiveNav(page); if(page === 'home') renderHome(); else if(page === 'changes') renderChanges(); else if(page === 'contact') renderContact(); }
    navButtons.home.addEventListener('click', ()=>navigateTo('home'));
    navButtons.changes.addEventListener('click', ()=>navigateTo('changes'));
    navButtons.contact.addEventListener('click', ()=>navigateTo('contact'));
    window.addEventListener('popstate', ()=>{ const page = (location.hash || '#home').replace('#','') || 'home'; setActiveNav(page); if(page === 'home') renderHome(); else if(page === 'changes') renderChanges(); else if(page === 'contact') renderContact(); });

    async function renderHome(){ await renderSetupView(); }

    const CHANGELOG = [
      { version: "0.9.7", date: "2025-12-07", notes: "Show  to/from on each panel; incoming editor updates opponent's outgoing." },
      { version: "0.9.6", date: "2025-12-06", notes: "Stable player order and edit restrictions; UI polish." }
    ];

    function renderChanges(){
      const appContainer = document.getElementById('app-container');
      let html = `<h2 style="margin-top:0;color:var(--text)">Changes</h2><div style="display:flex;flex-direction:column;gap:12px">`;
      CHANGELOG.forEach(entry=>{
        html += `<div style="background:#121416;padding:12px;border-radius:8px;border:1px solid var(--dark-border)"><div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700;color:var(--text)">${entry.version}</div><div class="muted">${entry.date}</div></div><div style="margin-top:8px;color:var(--text)">${entry.notes}</div></div>`;
      });
      html += `</div>`;
      appContainer.innerHTML = html;
    }

    function renderContact(){
      const appContainer = document.getElementById('app-container');
      appContainer.innerHTML = `
        <h2 style="margin-top:0;color:var(--text)">Contact</h2>
        <p class="muted">To contact me, please use your email client. Click the button below to open a new message addressed to <strong>CardboardBonfire@gmail.com</strong>.</p>
        <div style="max-width:640px">
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="contact-mailto" class="btn-primary">Email CardboardBonfire@gmail.com</button>
            <button id="contact-copy" class="btn-secondary">Copy Email</button>
          </div>
          <p id="contact-status" class="muted" style="margin-top:8px"></p>
        </div>
      `;
      document.getElementById('contact-mailto').addEventListener('click', ()=>{
        const subject = encodeURIComponent("Contact from MTG Life Tracker");
        const body = encodeURIComponent("Hi,\n\nI'd like to get in touch regarding...");
        window.location.href = `mailto:CardboardBonfire@gmail.com?subject=${subject}&body=${body}`;
      });
      document.getElementById('contact-copy').addEventListener('click', async ()=>{
        const status = document.getElementById('contact-status');
        try{ await navigator.clipboard.writeText('CardboardBonfire@gmail.com'); status.textContent = 'Email address copied to clipboard.'; }
        catch(e){ console.error(e); status.textContent = 'Unable to copy automatically — please copy: CardboardBonfire@gmail.com'; }
      });
    }

    // SETUP VIEW
    async function renderSetupView(){
      const appContainer = document.getElementById("app-container");
      const statusMessage = document.getElementById("status-message");
      roomId = null;
      document.getElementById('lobby-card-preview').style.display = 'none';
      document.getElementById('card-search-modal').style.display = 'none';
      statusMessage.textContent = "Browse rooms or create a new one.";
      statusMessage.style.color = "#9aa3ad";

      let listHtml = '<p style="color:var(--text)">Loading active rooms...</p>';
      appContainer.innerHTML = `
        <div style="display:flex;gap:12px;align-items:center;margin-bottom:12px">
          <div style="flex:1"><input type="text" id="search-input" placeholder="Enter Room ID to Create/Search"></div>
          <div style="width:160px"><button id="search-btn" class="btn-primary" style="width:100%">Find or Create Room</button></div>
        </div>
        <h3 style="color:var(--text);margin-top:0">Active Rooms</h3>
        <div id="room-list-container">${listHtml}</div>
        <div style="margin-top:12px"><button id="delete-all-rooms-btn" class="btn-danger">Delete All Rooms (Admin)</button></div>
      `;

      try{
        const q = query(collection(db, ROOM_COLLECTION), limit(15));
        const snap = await getDocs(q);
        if(snap.empty) listHtml = '<p style="color:var(--text)">No active rooms. Create one above!</p>';
        else{
          listHtml = '';
          snap.forEach(docSnap=>{
            const rData = docSnap.data();
            const rId = docSnap.id;
            const pCount = Object.keys(rData.players || {}).length;
            const ownerPlayer = rData.players[rData.ownerId];
            const ownerCmdName = ownerPlayer?.commanderName || ownerPlayer?.commander || 'N/A';
            const ownerCmdImage = ownerPlayer?.commanderImageUrl || '';
            const ownerName = ownerPlayer?.name || 'Owner';

            // compute createdAt and time left
            const createdAtTs = rData.createdAt?.toDate ? rData.createdAt.toDate() : null;
            const lastChangeTs = rData.lastLifeChange?.toDate ? rData.lastLifeChange.toDate() : createdAtTs;
            const now = new Date();
            const expiresAt = lastChangeTs ? new Date(lastChangeTs.getTime() + TIMEOUT_MINUTES * 60 * 1000) : null;
            const timeLeftMs = expiresAt ? Math.max(0, expiresAt.getTime() - now.getTime()) : null;
            const minutesLeft = timeLeftMs ? Math.floor(timeLeftMs / (60*1000)) : null;
            const secondsLeft = timeLeftMs ? Math.floor((timeLeftMs % (60*1000)) / 1000) : null;
            const timeLeftLabel = expiresAt ? `${minutesLeft}m ${secondsLeft}s` : '—';
            const createdLabel = createdAtTs ? createdAtTs.toLocaleString() : 'Unknown';

            listHtml += `
              <div class="room-item" data-rid="${rId}" style="display:flex;justify-content:space-between;align-items:center;background-color:#121416;padding:12px;margin-bottom:8px;border-radius:8px;border:1px solid var(--dark-border)">
                <div class="room-info">
                  <div style="font-weight:800;color:var(--text)">${rId}</div>
                  <div style="font-size:.9em;color:var(--muted);margin-top:6px">
                    ${pCount} Player(s) • Owner: ${ownerName}
                    <span class="lobby-cmd-name" data-img-url="${ownerCmdImage}" title="${ownerCmdName}" style="cursor:pointer;margin-left:8px;color:var(--muted);font-weight:700">Show CMD</span>
                    <div style="margin-top:6px;color:var(--muted);font-size:.85rem">
                      Created: <strong style="color:var(--text)">${createdLabel}</strong> • Expires in: <strong style="color:var(--text)">${timeLeftLabel}</strong>
                    </div>
                  </div>
                </div>
                <div><button class="join-btn btn-secondary" data-rid="${rId}" style="width:auto">Join</button></div>
              </div>
            `;
          });
        }
      }catch(e){
        console.error("List error:",e);
        listHtml = `<p style="color:#ff5555">Error loading rooms. Permissions might be initializing...</p>`;
      }

      const listContainer = document.getElementById("room-list-container");
      if(listContainer) listContainer.innerHTML = listHtml;

      if(listContainer){
        listContainer.querySelectorAll('.join-btn').forEach(btn=>{
          btn.addEventListener('click', (e)=> promptPassword(e.target.dataset.rid, 'join'));
        });

        const previewCardEl = document.getElementById('lobby-card-preview');
        const previewImgEl = document.getElementById('preview-img');

        listContainer.querySelectorAll('.lobby-cmd-name').forEach(cmdSpan=>{
          const imageUrl = cmdSpan.dataset.imgUrl;
          cmdSpan.addEventListener('mouseenter', ()=>{
            if(imageUrl && previewCardEl && previewImgEl){ previewImgEl.src = imageUrl; previewCardEl.style.display = 'block'; }
          });
          cmdSpan.addEventListener('mouseleave', ()=>{
            if(previewCardEl){ previewCardEl.style.display = 'none'; previewImgEl.src = ''; }
          });
          // also allow click to toggle preview
          cmdSpan.addEventListener('click', ()=>{
            if(imageUrl && previewCardEl && previewImgEl){
              if(previewCardEl.style.display === 'block'){ previewCardEl.style.display = 'none'; previewImgEl.src = ''; }
              else { previewImgEl.src = imageUrl; previewCardEl.style.display = 'block'; }
            }
          });
        });
      }

      document.getElementById("search-btn").onclick = async ()=>{
        const val = document.getElementById("search-input").value.trim().toLowerCase();
        if(!val) return;
        const snap = await getDoc(doc(db, ROOM_COLLECTION, val));
        if(snap.exists()) promptPassword(val,'join'); else promptPassword(val,'create');
      };

      document.getElementById("delete-all-rooms-btn").addEventListener('click', deleteAllRooms);
    }

    // RENDER ROOM VIEW
    function renderChat(chatLog, playerName){
      const chatLogDiv = document.getElementById('chat-log');
      if(!chatLogDiv) return;
      chatLogDiv.innerHTML = '';
      const displayLog = (chatLog || []).slice(-200);
      displayLog.forEach(msg=>{
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('chat-message');
        const senderSpan = document.createElement('span');
        senderSpan.classList.add('chat-sender');
        if(msg.senderName === 'System'){ senderSpan.classList.add('system'); senderSpan.textContent = 'System:'; }
        else senderSpan.textContent = `${msg.senderName}:`;
        messageDiv.appendChild(senderSpan);
        if(msg.cardImageUrl){
          const cardSpan = document.createElement('span');
          cardSpan.classList.add('chat-card');
          cardSpan.textContent = ` ${msg.message} `;
          cardSpan.dataset.cardImageUrl = msg.cardImageUrl;
          cardSpan.dataset.cardName = msg.message;
          messageDiv.appendChild(cardSpan);
          cardSpan.addEventListener('mouseenter', (e)=>{ showChatCardPreview(cardSpan.dataset.cardImageUrl, cardSpan.dataset.cardName); });
          cardSpan.addEventListener('mouseleave', (e)=>{ hideChatCardPreviewWithDelay(); });
          cardSpan.addEventListener('click', (e)=>{ const preview = document.getElementById('chat-card-preview'); if(preview.style.display === 'block') hideChatCardPreviewImmediate(); else showChatCardPreview(cardSpan.dataset.cardImageUrl, cardSpan.dataset.cardName); });
        } else {
          messageDiv.appendChild(document.createTextNode(' ' + msg.message));
        }
        chatLogDiv.appendChild(messageDiv);
      });
      chatLogDiv.scrollTop = chatLogDiv.scrollHeight;
    }

    let chatPreviewHideTimer = null;
    function showChatCardPreview(imageUrl, title){
      if(chatPreviewHideTimer){ clearTimeout(chatPreviewHideTimer); chatPreviewHideTimer = null; }
      const preview = document.getElementById('chat-card-preview');
      const img = document.getElementById('chat-preview-img');
      const t = document.getElementById('chat-preview-title');
      img.src = imageUrl; t.textContent = title; preview.style.display = 'block';
    }
    function hideChatCardPreviewWithDelay(){ if(chatPreviewHideTimer) clearTimeout(chatPreviewHideTimer); chatPreviewHideTimer = setTimeout(()=>{ hideChatCardPreviewImmediate(); }, 300); }
    function hideChatCardPreviewImmediate(){ const preview = document.getElementById('chat-card-preview'); const img = document.getElementById('chat-preview-img'); const t = document.getElementById('chat-preview-title'); preview.style.display = 'none'; img.src = ''; t.textContent = ''; if(chatPreviewHideTimer){ clearTimeout(chatPreviewHideTimer); chatPreviewHideTimer = null; } }

    // SUBSCRIBE / ROOM LIFECYCLE
    async function subscribeToRoom(rid){
      if(unsubscribe) unsubscribe();
      const roomRef = doc(db, ROOM_COLLECTION, rid);
      unsubscribe = onSnapshot(roomRef, snap => {
        if(!snap.exists()){
          // room deleted or expired
          clearPersistedRoom();
          renderSetupView();
          return;
        }
        const data = snap.data();
        renderRoomView(data);
      }, err => {
        console.error('Room snapshot error', err);
      });
    }

    // Prompt for password or create/join flow (simple)
    async function promptPassword(rid, mode){
      // For simplicity this app uses no password by default. If you have password logic, integrate here.
      if(mode === 'create'){
        // create a new room with initial player as owner
        const newRoomId = rid;
        // create a minimal player object for the owner
        const uid = userId || `anon_${Date.now()}`;
        userId = uid;
        const initialPlayer = {
          name: 'You',
          life: getStartingLife(),
          commanderName: '',
          commanderImageUrl: '',
          infect: 0,
          commanderDamage: {}
        };
        const initialPlayers = {};
        initialPlayers[uid] = initialPlayer;
        const initialOrder = [uid];
        try{
          await setDoc(doc(db, ROOM_COLLECTION, newRoomId), {
            ownerId: uid,
            players: initialPlayers,
            playersOrder: initialOrder,
            createdAt: serverTimestamp(),
            lastLifeChange: serverTimestamp(),
            chat: []
          });
          roomId = newRoomId;
          persistJoinedRoom(roomId, userId);
          await subscribeToRoom(roomId);
        }catch(e){
          console.error('Create room failed', e);
          alert('Failed to create room. See console.');
        }
      } else {
        // join existing room
        const snap = await getDoc(doc(db, ROOM_COLLECTION, rid));
        if(!snap.exists()){
          alert('Room not found.');
          return;
        }
        const data = snap.data();
        const uid = userId || `anon_${Date.now()}`;
        userId = uid;
        // add player if not present
        if(!data.players || !data.players[uid]){
          const playerObj = {
            name: 'You',
            life: getStartingLife(),
            commanderName: '',
            commanderImageUrl: '',
            infect: 0,
            commanderDamage: {}
          };
          try{
            await updateDoc(doc(db, ROOM_COLLECTION, rid), {
              [`players.${uid}`]: playerObj,
              playersOrder: arrayUnion(uid)
            });
          }catch(e){
            // fallback to setDoc merge
            try{
              await setDoc(doc(db, ROOM_COLLECTION, rid), {
                [`players.${uid}`]: playerObj,
                playersOrder: arrayUnion(uid)
              }, { merge: true });
            }catch(err){ console.error('Failed to add player', err); }
          }
        }
        roomId = rid;
        persistJoinedRoom(roomId, userId);
        await subscribeToRoom(roomId);
      }
    }

    // Leave room
    async function leaveRoom(){
      if(!roomId || !userId) { clearPersistedRoom(); renderSetupView(); return; }
      try{
        // remove player from room document (simple approach: set to null)
        const playerPath = `players.${userId}`;
        await updateDoc(doc(db, ROOM_COLLECTION, roomId), {
          [playerPath]: null
        });
      }catch(e){ console.warn('Failed to remove player from room', e); }
      clearPersistedRoom();
      if(unsubscribe) unsubscribe();
      unsubscribe = null;
      roomId = null;
      renderSetupView();
    }

    // Delete all rooms (admin)
    async function deleteAllRooms(){
      const pwd = prompt('Enter admin password to delete all rooms:');
      if(pwd !== DELETE_ALL_PWD) { alert('Incorrect password'); return; }
      try{
        const q = query(collection(db, ROOM_COLLECTION), limit(200));
        const snap = await getDocs(q);
        const deletes = [];
        snap.forEach(s => deletes.push(deleteDoc(doc(db, ROOM_COLLECTION, s.id))));
        await Promise.all(deletes);
        alert('Deleted rooms.');
        renderSetupView();
      }catch(e){ console.error('Delete all failed', e); alert('Failed to delete rooms.'); }
    }

    // Update life and set lastLifeChange timestamp
    async function updatePlayerLife(targetPlayerId, newLife){
      if(!roomId) return;
      try{
        await updateDoc(doc(db, ROOM_COLLECTION, roomId), {
          [`players.${targetPlayerId}.life`]: newLife,
          lastLifeChange: serverTimestamp()
        });
      }catch(e){
        console.error('Failed to update life', e);
      }
    }

    // Update commander damage (per-opponent) and set lastLifeChange
    async function updateCommanderDamage(sourcePlayerId, targetPlayerId, newValue){
      if(!roomId) return;
      try{
        await updateDoc(doc(db, ROOM_COLLECTION, roomId), {
          [`players.${sourcePlayerId}.commanderDamage.${targetPlayerId}`]: newValue,
          lastLifeChange: serverTimestamp()
        });
      }catch(e){ console.error('Failed to update commander damage', e); }
    }

    // Infect update
    async function updateInfect(playerId, newVal){
      if(!roomId) return;
      try{
        await updateDoc(doc(db, ROOM_COLLECTION, roomId), {
          [`players.${playerId}.infect`]: newVal,
          lastLifeChange: serverTimestamp()
        });
      }catch(e){ console.error('Failed to update infect', e); }
    }

    // Periodic cleanup of expired rooms (client-side)
    async function checkAndCloseExpiredRooms(){
      try{
        const now = Date.now();
        const q = query(collection(db, ROOM_COLLECTION), limit(100));
        const snap = await getDocs(q);
        snap.forEach(async docSnap => {
          const data = docSnap.data();
          const rid = docSnap.id;
          const last = data.lastLifeChange;
          const ts = last?.toDate ? last.toDate() : (data.createdAt?.toDate ? data.createdAt.toDate() : null);
          if(!ts) return;
          const ageMinutes = (now - ts.getTime()) / (60*1000);
          if(ageMinutes >= TIMEOUT_MINUTES){
            try{
              await deleteDoc(doc(db, ROOM_COLLECTION, rid));
              console.log('Deleted expired room', rid);
            }catch(e){ console.warn('Failed to delete expired room', rid, e); }
          }
        });
      }catch(e){ console.error('Error checking expired rooms', e); }
    }

    // start the interval once after init
    setInterval(checkAndCloseExpiredRooms, 60 * 1000); // every minute
    checkAndCloseExpiredRooms();

    // RENDER ROOM VIEW (continued)
    function renderRoomView(roomData){
      const appContainer = document.getElementById("app-container");
      const statusMessage = document.getElementById("status-message");
      document.getElementById('lobby-card-preview').style.display = 'none';
      document.getElementById('card-search-modal').style.display = 'none';
      const currentPlayerName = roomData.players[userId]?.name || 'You';
      statusMessage.innerHTML = `Connected as: <strong>${currentPlayerName}</strong>`;

      let html = `
        <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px">
          <div>
            <h2 style="margin:0;color:var(--text)">Room: ${roomId}</h2>
            <div style="color:var(--muted);font-size:.9rem;margin-top:6px">Players: ${Object.keys(roomData.players).length}</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="card-search-btn" class="btn-secondary">Card Search</button>
            <button id="restart-game-btn" class="btn-secondary">Restart Game</button>
            <button id="share-invite-btn" class="btn-secondary">Share Invite</button>
            <button id="leave-room-btn" class="btn-danger">Leave Room</button>
          </div>
        </div>
      `;

      const playerIds = Array.isArray(roomData.playersOrder) && roomData.playersOrder.length ? [...roomData.playersOrder] : Object.keys(roomData.players || {});
      if (playerIds.includes(userId)) { const idx = playerIds.indexOf(userId); if (idx > 0) { playerIds.splice(idx, 1); playerIds.unshift(userId); } }
      else if (roomData.players && roomData.players[userId]) playerIds.unshift(userId);

      html += `<div class="player-grid">`;
      playerIds.forEach(playerId=>{
        const player = roomData.players[playerId];
        if(!player) return;
        const isMe = playerId === userId;
        const life = player.life ?? getStartingLife();
        const commanderName = player.commanderName || player.commander || 'N/A';
        const infectVal = player.infect || 0;

        // Build per-opponent rows: show the damage that each opponent has dealt to this player.
        let perOppRows = '';
        const opponents = playerIds.filter(id => id !== playerId);
        if(opponents.length > 0){
          opponents.forEach(oppId => {
            const dmg = (roomData.players[oppId]?.commanderDamage || {})[playerId] || 0;
            const oppName = roomData.players[oppId]?.name || 'Player';
            const editable = (playerId === userId);
            const disabledAttr = editable ? '' : 'disabled';
            perOppRows += `
              <div class="per-opp-row" data-target="${playerId}" data-opp="${oppId}">
                <div class="per-opp-left">From <strong>${oppName}</strong></div>
                <div class="per-opp-controls">
                  <button class="control-btn negative small-btn" data-action="cmd-target-sub" data-target="${playerId}" data-opp="${oppId}" ${disabledAttr}>-</button>
                  <input type="number" value="${dmg}" data-target="${playerId}" data-opp="${oppId}" class="cmd-target-input" style="width:64px;padding:6px;border-radius:6px;border:1px solid var(--dark-border);background:var(--input-bg);color:var(--text);text-align:center" ${disabledAttr}>
                  <button class="control-btn negative small-btn" data-action="cmd-target-add" data-target="${playerId}" data-opp="${oppId}" ${disabledAttr}>+</button>
                </div>
              </div>
            `;
          });
        }

        // Infect controls (only editable for your own player)
        const infectControlsHtml = `
          <div style="display:flex;align-items:center;gap:6px">
            <button class="control-btn small-btn" data-action="infect-sub" data-player="${playerId}" ${isMe ? '' : 'disabled'}>-</button>
            <div class="infect-value" id="infect-${playerId}">${infectVal}</div>
            <button class="control-btn small-btn" data-action="infect-add" data-player="${playerId}" ${isMe ? '' : 'disabled'}>+</button>
          </div>
        `;

        // CMD block: show both "to" (outgoing total) and "from" (incoming total)
        const outgoingTotal = computeOutgoingTotal(roomData, playerId);
        const incomingTotal = computeIncomingCmdDamage(roomData, playerId);

        html += `
          <div class="player-panel" id="panel-${playerId}">
            <div class="player-header">
              <div>
                <div class="player-name">${player.name || (isMe ? 'You' : 'Player')}</div>
                <div class="player-sub">${commanderName}</div>
              </div>
              <div style="text-align:right">
                ${isMe ? '<div class="you-badge">YOU</div>' : ''}
              </div>
            </div>
            <div style="display:flex;justify-content:space-between;align-items:center;gap:12px">
              <div>
                <div class="life-big" id="life-${playerId}">${life}</div>
                <div style="margin-top:8px">${infectControlsHtml}</div>
              </div>
              <div style="min-width:220px">
                <div class="cmd-block">
                  <div>
                    <div class="cmd-label">CMD to others</div>
                    <div class="cmd-value">${outgoingTotal}</div>
                  </div>
                  <div>
                    <div class="cmd-label">CMD from others</div>
                    <div class="cmd-value">${incomingTotal}</div>
                  </div>
                </div>
                <div class="per-opp-container">
                  ${perOppRows}
                </div>
              </div>
            </div>
          </div>
        `;
      });
      html += `</div>`; // player-grid

      // Chat area and footer
      html += `
        <div style="margin-top:12px;display:flex;gap:12px;align-items:flex-start">
          <div style="flex:1">
            <div id="chat-log"></div>
            <div style="display:flex;gap:8px">
              <input id="chat-input" placeholder="Say something..." style="flex:1">
              <button id="chat-send" class="btn-primary">Send</button>
            </div>
          </div>
          <div style="width:260px">
            <div style="background:rgba(255,255,255,0.02);padding:12px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)">
              <div style="font-weight:800;color:var(--text)">Room Info</div>
              <div style="margin-top:8px;color:var(--muted)">Created: <span id="room-created">—</span></div>
              <div style="margin-top:6px;color:var(--muted)">Expires in: <span id="room-expires">—</span></div>
            </div>
          </div>
        </div>
      `;

      appContainer.innerHTML = html;

      // Wire up buttons
      document.getElementById('leave-room-btn').addEventListener('click', async ()=>{
        await leaveRoom();
      });

      document.getElementById('chat-send').addEventListener('click', async ()=>{
        const input = document.getElementById('chat-input');
        const text = input.value.trim();
        if(!text) return;
        try{
          // append to chat array (simple append)
          const roomRef = doc(db, ROOM_COLLECTION, roomId);
          await updateDoc(roomRef, {
            chat: arrayUnion({ senderId: userId, senderName: roomData.players[userId]?.name || 'You', message: text, timestamp: serverTimestamp() })
          });
          input.value = '';
        }catch(e){ console.error('Failed to send chat', e); }
      });

      // Wire up per-opponent controls and inputs
      document.querySelectorAll('.cmd-target-input').forEach(inputEl=>{
        inputEl.addEventListener('change', async (e)=>{
          const target = e.target.dataset.target;
          const opp = e.target.dataset.opp;
          const val = parseInt(e.target.value) || 0;
          await updateCommanderDamage(opp, target, val);
        });
      });
      document.querySelectorAll('[data-action="cmd-target-add"]').forEach(btn=>{
        btn.addEventListener('click', async (e)=>{
          const target = e.target.dataset.target;
          const opp = e.target.dataset.opp;
          const current = parseInt(document.querySelector(`.cmd-target-input[data-target="${target}"][data-opp="${opp}"]`)?.value || 0);
          await updateCommanderDamage(opp, target, current + 1);
        });
      });
      document.querySelectorAll('[data-action="cmd-target-sub"]').forEach(btn=>{
        btn.addEventListener('click', async (e)=>{
          const target = e.target.dataset.target;
          const opp = e.target.dataset.opp;
          const current = parseInt(document.querySelector(`.cmd-target-input[data-target="${target}"][data-opp="${opp}"]`)?.value || 0);
          await updateCommanderDamage(opp, target, Math.max(0, current - 1));
        });
      });

      // Infect controls
      document.querySelectorAll('[data-action="infect-add"]').forEach(btn=>{
        btn.addEventListener('click', async (e)=>{
          const pid = e.target.dataset.player;
          const cur = parseInt(document.getElementById(`infect-${pid}`).textContent || 0);
          await updateInfect(pid, cur + 1);
        });
      });
      document.querySelectorAll('[data-action="infect-sub"]').forEach(btn=>{
        btn.addEventListener('click', async (e)=>{
          const pid = e.target.dataset.player;
          const cur = parseInt(document.getElementById(`infect-${pid}`).textContent || 0);
          await updateInfect(pid, Math.max(0, cur - 1));
        });
      });

      // Update room info (created and expires)
      const createdEl = document.getElementById('room-created');
      const expiresEl = document.getElementById('room-expires');
      const createdAtTs = roomData.createdAt?.toDate ? roomData.createdAt.toDate() : null;
      const lastChangeTs = roomData.lastLifeChange?.toDate ? roomData.lastLifeChange.toDate() : createdAtTs;
      createdEl.textContent = createdAtTs ? createdAtTs.toLocaleString() : 'Unknown';
      function updateExpires(){
        const now = new Date();
        const expiresAt = lastChangeTs ? new Date(lastChangeTs.getTime() + TIMEOUT_MINUTES * 60 * 1000) : null;
        if(!expiresAt){ expiresEl.textContent = '—'; return; }
        const diff = Math.max(0, expiresAt.getTime() - now.getTime());
        const m = Math.floor(diff / (60*1000));
        const s = Math.floor((diff % (60*1000)) / 1000);
        expiresEl.textContent = `${m}m ${s}s`;
      }
      updateExpires();
      setInterval(updateExpires, 1000);
    }

    // Attempt to rejoin persisted room on load
    (async function tryRestoreRoomOnLoad(){
      const persisted = getPersistedRoom();
      if(persisted.roomId){
        try{
          const snap = await getDoc(doc(db, ROOM_COLLECTION, persisted.roomId));
          if(snap.exists()){
            roomId = persisted.roomId;
            if(persisted.userId) userId = persisted.userId;
            await subscribeToRoom(roomId);
            return;
          } else {
            clearPersistedRoom();
          }
        }catch(e){ console.error('Restore room failed', e); clearPersistedRoom(); }
      }
      // If no persisted room, render setup
      const page = (location.hash || '#home').replace('#','') || 'home';
      if(page === 'home') renderSetupView(); else if(page === 'changes') renderChanges(); else if(page === 'contact') renderContact();
    })();

    // AUTH: sign in anonymously if needed
    (async function initAuth(){
      try{
        await signInAnonymously(auth);
        onAuthStateChanged(auth, (user)=>{
          if(user) userId = user.uid;
        });
      }catch(e){ console.error('Auth init failed', e); }
    })();

    // Scryfall modal wiring (basic)
    document.addEventListener('click', (e)=>{
      if(e.target && e.target.id === 'card-search-btn'){
        document.getElementById('card-search-modal').style.display = 'flex';
      }
      if(e.target && e.target.id === 'modal-close-btn'){
        document.getElementById('card-search-modal').style.display = 'none';
      }
    });

    // Small utility: show lobby preview hide on resize small screens
    window.addEventListener('resize', ()=>{
      if(window.innerWidth <= 720){
        document.getElementById('lobby-card-preview').style.display = 'none';
        document.getElementById('chat-card-preview').style.display = 'none';
      }
    });

  </script>
</body>
</html>
