<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MTG Life Tracker</title>
  <style>
    :root{
      --bg:#0f1113;--card:#16181a;--muted:#9aa3ad;--text:#e6eef6;
      --accent:#2980b9;--accent-strong:#1f6fa8;--green:#27ae60;--red:#c0392b;
      --dark-border:#22272a;--input-bg:#1f2326;
    }
    html,body{height:100%;margin:0}
    body{
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background:var(--bg);color:var(--text);display:flex;flex-direction:column;
      align-items:center;padding:20px;box-sizing:border-box;min-height:100vh;
    }
    header.app-header{width:100%;max-width:1100px;display:flex;justify-content:space-between;align-items:center;margin-bottom:18px;gap:12px}
    .brand{display:flex;flex-direction:column;gap:2px}
    .app-title{margin:0;font-size:1.25rem;color:var(--text)}
    .app-subtitle{margin:0;font-size:0.8rem;color:var(--muted);font-style:italic}
    nav.site-nav{display:flex;gap:8px}
    nav.site-nav button{background:transparent;color:var(--text);border:1px solid transparent;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
    nav.site-nav button.active{background:rgba(41,128,185,0.10);border-color:var(--accent)}
    #app-container{width:100%;max-width:1100px;background:var(--card);padding:20px;border-radius:12px;box-shadow:0 6px 30px rgba(0,0,0,0.6);box-sizing:border-box;position:relative}
    input,textarea,select{width:100%;padding:12px;margin-bottom:10px;border-radius:8px;border:1px solid var(--dark-border);background:var(--input-bg);color:var(--text);box-sizing:border-box}
    textarea{min-height:120px;resize:vertical}
    input,button,textarea,select{-webkit-appearance:none;appearance:none;-webkit-tap-highlight-color:transparent}
    *:focus,*:focus-visible,*:focus-within{outline:none!important;box-shadow:none!important}
    button{cursor:pointer;border-radius:8px;padding:10px 12px;border:none;font-weight:700;transition:transform .08s ease,opacity .12s}
    button:active,.tapped{transform:scale(.96)}
    .btn-primary{background:linear-gradient(180deg,var(--green),#1f8a4a);color:#fff}
    .btn-danger{background:linear-gradient(180deg,var(--red),#9b2b24);color:#fff}
    .btn-secondary{background:linear-gradient(180deg,#3a3a3a,#2f2f2f);color:#fff}
    button:disabled, input:disabled { opacity: .45;
    cursor: not-allowed; filter: grayscale(.2); }
    .player-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:16px;margin-top:12px}
    @media(max-width:900px){.player-grid{grid-template-columns:1fr}}
    .player-panel{background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0.00));border:1px solid var(--dark-border);border-radius:12px;padding:14px;display:flex;flex-direction:column;gap:10px;position:relative;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
    .player-header{display:flex;justify-content:space-between;align-items:center;gap:8px}
    .player-name{font-weight:800;font-size:1rem;color:var(--text)}
    .player-sub{font-size:.85rem;color:var(--muted)}
    .life-big{font-size:3.2rem;font-weight:900;color:var(--text);letter-spacing:-1px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .control-btn{padding:8px 12px;border-radius:8px;font-weight:800;min-width:56px;text-align:center;background:linear-gradient(180deg,#2b2b2b,#232323);color:var(--text);border:1px solid rgba(255,255,255,0.03);cursor:pointer;display:inline-flex;align-items:center;justify-content:center}
    .control-btn.positive{background:linear-gradient(180deg,#2ecc71,#27ae60);color:#04260a}
    .control-btn.negative{background:linear-gradient(180deg,#ff6b6b,#c0392b);color:#2b0706}
    .cmd-block{display:flex;justify-content:space-between;align-items:center;gap:8px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    .cmd-label{font-size:.9rem;color:var(--muted)}
    .cmd-value{font-weight:800;color:#ffb3b3}
    .you-badge{background:linear-gradient(90deg,var(--accent),var(--accent-strong));color:#fff;padding:6px 8px;border-radius:999px;font-weight:800;font-size:.8rem}
    .cmd-controls{display:none;margin-top:10px}
    .cmd-controls.open{display:block}
    .per-opp-container{margin-top:10px;display:flex;flex-direction:column;gap:6px;max-height:160px;overflow:auto;border-top:1px solid rgba(255,255,255,0.02);padding-top:8px}
    .per-opp-row{height:44px;display:flex;justify-content:space-between;align-items:center;gap:8px;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02);box-sizing:border-box}
    
    .per-opp-left{font-size:0.9em;color:var(--muted);font-weight:700}
    .per-opp-controls{display:flex;align-items:center;gap:8px}
    .outgoing-cmd-list{display:flex;flex-direction:column;gap:6px;margin-top:8px}
    .outgoing-cmd-item{font-size:0.95rem;color:var(--text);display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
    .infect-block{margin-top:8px;display:flex;align-items:center;gap:8px}
    .infect-label{font-size:0.85rem;color:var(--muted)}
    .infect-value{font-weight:800;color:#bfe6a8;min-width:36px;text-align:center}
    .small-btn{padding:6px 8px;font-size:0.85rem;min-width:36px;border-radius:6px}
    #chat-log{height:300px;overflow-y:auto;border:1px solid rgba(255,255,255,0.03);padding:10px;margin-bottom:10px;border-radius:8px;background:#0f1113;font-size:.95em}
    .chat-message{margin-bottom:6px;display:flex;gap:8px;align-items:center}
    .chat-sender{font-weight:800;color:#74b9ff;margin-right:6px}
    .chat-sender.system{color:#ffd166;font-weight:900}
    .chat-card{display:inline-block;position:relative;cursor:pointer;color:var(--text);text-decoration:underline dotted rgba(255,255,255,0.08)}
    #chat-card-preview{position:fixed;top:50%;right:20px;transform:translateY(-50%);width:300px;max-width:40vw;border:3px solid var(--accent);border-radius:10px;box-shadow:0 12px 40px rgba(0,0,0,0.7);background:#0b0d0f;z-index:1500;display:none;padding:8px}
    #chat-card-preview img{display:block;width:100%;border-radius:6px}
    #chat-card-preview .card-title{margin-top:8px;font-weight:800;color:var(--text);text-align:center}
    .modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.6);display:none;justify-content:center;align-items:center;z-index:2000}
    .modal-content{background:#16181a;color:var(--text);padding:20px;border-radius:10px;width:92%;max-width:520px;box-shadow:0 12px 40px rgba(0,0,0,.7);position:relative}
    .suggestions-list{position:absolute;width:100%;background:var(--input-bg);border:1px solid var(--dark-border);border-top:none;max-height:150px;overflow-y:auto;z-index:100;border-radius:0 0 8px 8px;box-shadow:0 6px 18px rgba(0,0,0,.6);margin-top:-10px}
  
    .suggestions-list:empty{display:none!important;border:none!important;box-shadow:none!important;margin-top:0!important}
    .suggestion-item{padding:8px 12px;cursor:pointer;color:var(--text)}
    .suggestion-item:hover{background:rgba(41,128,185,.08)}
    #lobby-card-preview{position:fixed;top:50%;left:20px;transform:translateY(-50%);width:260px;border:3px solid var(--accent);border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.8);z-index:999;display:none;background:#0b0d0f}
    #lobby-card-preview img{display:block;width:100%;border-radius:6px}
    #lobby-features{margin-top:18px;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    #room-footer{margin-top:14px;color:var(--muted);font-size:.9rem;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .muted{color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
    .col{display:flex;flex-direction:column;gap:8px}
    /* Chat full width container */
    #chat-container{width:100%;margin-top:18px}
    #chat-controls{display:flex;gap:8px;align-items:center}
    @media(max-width:720px){header.app-header{flex-direction:column;align-items:flex-start;gap:8px}#lobby-card-preview{display:none!important}#chat-card-preview{display:none!important}}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
</head>
<body>
  <header class="app-header" role="banner">
    <div class="brand">
      <h1 class="app-title">Cardboard Bonfire</h1>
      <div class="app-subtitle">Life tracker for keeping life 
 and bringing people together.</div>
    </div>
    <nav class="site-nav" role="navigation" aria-label="Main">
      <button id="nav-home" class="nav-btn">Home</button>
      <button id="nav-changes" class="nav-btn">Changes</button>
      <button id="nav-contact" class="nav-btn">Contact</button>
    </nav>
  </header>

  <main id="app-container" role="main"></main>

  <div id="lobby-card-preview" aria-hidden="true"><img id="preview-img" alt="Commander Preview"></div>
  <div id="chat-card-preview" aria-hidden="true"><img id="chat-preview-img" alt="Card Preview"><div class="card-title" id="chat-preview-title"></div></div>
  <p id="status-message" class="muted">Initializing...</p>

  <div id="card-search-modal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <h3 style="margin-top:0">Card Search (Scryfall)</h3>
      <input type="text" id="modal-card-name" placeholder="Enter card name" autocomplete="off">
 
      <div id="modal-suggestions-list" class="suggestions-list"></div>
      <div style="display:flex;gap:8px;margin-top:10px;">
        <button id="modal-search-btn" class="btn-primary">Search & Post</button>
        <button id="modal-close-btn" class="btn-secondary">Close</button>
      </div>
      <div id="search-results" style="margin-top:12px"></div>
    </div>
  </div>

  <div id="edit-commander-modal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <h3 style="margin-top:0">Edit Commander</h3>
      <input type="text" id="edit-commander-name" placeholder="Commander name">
      <div id="edit-commander-suggestions" class="suggestions-list"></div>
      <div style="display:flex;gap:8px;margin-top:10px;">
 
        <button id="edit-commander-save" class="btn-primary">Save</button>
        <button id="edit-commander-cancel" class="btn-secondary">Cancel</button>
      </div>
      <div id="edit-commander-result" style="margin-top:12px"></div>
    </div>
  </div>

  <script type="module">
    // ----------------------------------------------------------------------
    // CONFIG
    // ----------------------------------------------------------------------
    const USER_FIREBASE_CONFIG = {
      apiKey: "AIzaSyA_mz_fVsph8VHfCEG__9sWg_ZvwYX5_6E",
      authDomain: "mtg-life-tool.firebaseapp.com",
      projectId: "mtg-life-tool",
      storageBucket: "mtg-life-tool.appspot.com",
      messagingSenderId: "36730058988",
 
      appId: "1:36730058988:web:757e2d9620593b4f65022a"
    };
    // TIMEOUT: set to 20 minutes per request
    const TIMEOUT_MINUTES = 20;

    const SCRYFALL_API = "https://api.scryfall.com/cards/named?exact=";
    const SCRYFALL_AUTOCOMPLETE_API = "https://api.scryfall.com/cards/autocomplete?q=";
    const DELETE_ALL_PWD = "DeleteAllRooms";
    const AUTOCOMPLETE_DEBOUNCE_MS = 100;
    // ----------------------------------------------------------------------
    // IMPORTS
    // ----------------------------------------------------------------------
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, onSnapshot, serverTimestamp,
      arrayUnion, deleteDoc, collection, getDocs, query, limit, updateDoc
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    // ----------------------------------------------------------------------
    // GLOBALS
    // ----------------------------------------------------------------------
    const app = initializeApp(USER_FIREBASE_CONFIG);
    const auth = getAuth(app);
    const db = getFirestore(app);

    let userId = null;
    let roomId = null;
    let unsubscribe = null;
    let autocompleteTimeout = null;
    const ROOM_COLLECTION = "mtg_rooms";

    // Track which players' CMD controls are open (persist across renders)
    const openCmdControls = new Set();
    // ----------------------------------------------------------------------
    // HELPERS
    // ----------------------------------------------------------------------
    function hashPassword(password){ return CryptoJS.SHA256(password).toString(CryptoJS.enc.Hex);
    }
    function getStartingLife(){ return 40; }

    async function validateCommander(name){
      if(!name) return null;
      try{
        const response = await fetch(`${SCRYFALL_API}${encodeURIComponent(name)}`);
        const data = await response.json();
        if(response.ok){
          const imageUrl = data.image_uris?.normal || data.card_faces?.[0]?.image_uris?.normal;
          if(imageUrl) return { validatedName: data.name, imageUrl };
        }
        return null;
      }catch(e){ console.error("Scryfall validation error:", e); return null; }
    }

    async function fetchAutocompleteSuggestions(query, listId, inputId){
      const suggestionsList = document.getElementById(listId);
      const inputField = document.getElementById(inputId);
      if(!suggestionsList || !inputField) return;
      suggestionsList.innerHTML = '';
      if(query.length < 2) return;
      try{
        const response = await fetch(`${SCRYFALL_AUTOCOMPLETE_API}${encodeURIComponent(query)}`);
        const data = await response.json();
        if(response.ok && data.data && data.data.length){
          data.data.slice(0,5).forEach(suggestion=>{
            const item = document.createElement('div');
            item.classList.add('suggestion-item');
            item.textContent = suggestion;
            item.onclick = () => { inputField.value = suggestion; suggestionsList.innerHTML = ''; };
            suggestionsList.appendChild(item);
          
          });
        }
      }catch(e){ console.error("Autocomplete error:", e);
      }
    }

    // compute outgoing map for a source player (what this player's commander has done to others)
    function computeOutgoingCmdDamage(roomData, sourcePlayerId){
      const players = roomData.players ||
      {};
      const order = Array.isArray(roomData.playersOrder) && roomData.playersOrder.length ? roomData.playersOrder : Object.keys(players || {});
      const result = [];
      order.forEach(pid => {
        if(pid === sourcePlayerId) return;
        const dmg = (players[sourcePlayerId]?.commanderDamage || {})[pid] || 0;
        const name = players[pid]?.name || 'Player';
        result.push({ oppId: pid, oppName: name, dmg });
      });
      return result;
    }

    // compute outgoing total for a source player (sum of their commanderDamage map)
    function computeOutgoingTotal(roomData, sourcePlayerId){
      const dmgMap = (roomData.players?.[sourcePlayerId]?.commanderDamage) ||
      {};
      return Object.keys(dmgMap).reduce((s,k)=> s + (parseInt(dmgMap[k])||0), 0);
    }

    // compute incoming total for a target player
    function computeIncomingCmdDamage(roomData, targetPlayerId){
      let total = 0;
      const players = roomData.players || {};
      Object.keys(players).forEach(pid=>{
        const dmgMap = players[pid]?.commanderDamage || {};
        const val = dmgMap[targetPlayerId] || 0;
        total += val;
      });
      return total;
    }

    // ----------------------------------------------------------------------
    // ROUTING & PAGES
    // ----------------------------------------------------------------------
    const navButtons = { home: document.getElementById('nav-home'), changes: document.getElementById('nav-changes'), contact: document.getElementById('nav-contact') };
    function setActiveNav(page){ Object.values(navButtons).forEach(b=>b.classList.remove('active')); if(navButtons[page]) navButtons[page].classList.add('active'); }
    function navigateTo(page){ if(location.hash !== `#${page}`) history.pushState(null,'',`#${page}`); setActiveNav(page); if(page === 'home') renderHome();
    else if(page === 'changes') renderChanges(); else if(page === 'contact') renderContact(); }
    navButtons.home.addEventListener('click', ()=>navigateTo('home'));
    navButtons.changes.addEventListener('click', ()=>navigateTo('changes'));
    navButtons.contact.addEventListener('click', ()=>navigateTo('contact'));
    window.addEventListener('popstate', ()=>{ const page = (location.hash || '#home').replace('#','') || 'home'; setActiveNav(page); if(page === 'home') renderHome(); else if(page === 'changes') renderChanges(); else if(page === 'contact') renderContact(); });
    async function renderHome(){ await renderSetupView(); }

    const CHANGELOG = [
      { version: "0.9.8", date: "2025-12-08", notes: "Show CMD labels, persist lobby on refresh, 20-minute timeout based on life changes, lobby timestamps."
    },
      { version: "0.9.7", date: "2025-12-07", notes: "Show CMD DMG to/from on each panel; incoming editor updates opponent's outgoing."
    }
    ];

    function renderChanges(){
      const appContainer = document.getElementById('app-container');
      let html = `<h2 style="margin-top:0;color:var(--text)">Changes</h2><div style="display:flex;flex-direction:column;gap:12px">`;
      CHANGELOG.forEach(entry=>{
        html += `<div style="background:#121416;padding:12px;border-radius:8px;border:1px solid var(--dark-border)"><div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700;color:var(--text)">${entry.version}</div><div class="muted">${entry.date}</div></div><div style="margin-top:8px;color:var(--text)">${entry.notes}</div></div>`;
      });
      html += `</div>`;
      appContainer.innerHTML = html;
    }

    function renderContact(){
      const appContainer = document.getElementById('app-container');
      appContainer.innerHTML = `
        <h2 style="margin-top:0;color:var(--text)">Contact</h2>
        <p class="muted">To contact me, please use your email client.
        Click the button below to open a new message addressed to <strong>CardboardBonfire@gmail.com</strong>.</p>
        <div style="max-width:640px">
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="contact-mailto" class="btn-primary">Email CardboardBonfire@gmail.com</button>
            <button id="contact-copy" class="btn-secondary">Copy Email</button>
          </div>
          <p id="contact-status" class="muted" style="margin-top:8px"></p>
        </div>
      `;
      document.getElementById('contact-mailto').addEventListener('click', ()=>{
        const subject = encodeURIComponent("Contact from MTG Life Tracker");
        const body = encodeURIComponent("Hi,\n\nI'd like to get in touch regarding...");
        window.location.href = `mailto:CardboardBonfire@gmail.com?subject=${subject}&body=${body}`;
      });
      document.getElementById('contact-copy').addEventListener('click', async ()=>{
        const status = document.getElementById('contact-status');
        try{ await navigator.clipboard.writeText('CardboardBonfire@gmail.com'); status.textContent = 'Email address copied to clipboard.'; }
        catch(e){ console.error(e); status.textContent = 'Unable to copy automatically — please copy: CardboardBonfire@gmail.com'; }
      });
    }

    // ----------------------------------------------------------------------
    // SETUP VIEW (room list + create)
    // ----------------------------------------------------------------------
    function formatTimeLeft(minutesLeft){
      if(minutesLeft <= 0) return 'closing soon';
      if(minutesLeft < 60) return `${Math.ceil(minutesLeft)}m left`;
      const hrs = Math.floor(minutesLeft/60);
      const mins = Math.ceil(minutesLeft%60);
      return `${hrs}h ${mins}m left`;
    }

    async function renderSetupView(){
      const appContainer = document.getElementById("app-container");
      const statusMessage = document.getElementById("status-message");
      roomId = null;
      document.getElementById('lobby-card-preview').style.display = 'none';
      document.getElementById('card-search-modal').style.display = 'none';
      statusMessage.textContent = "Browse rooms or create a new one.";
      statusMessage.style.color = "#9aa3ad";

      let listHtml = '<p style="color:var(--text)">Loading active rooms...</p>';
      appContainer.innerHTML = `
        <div style="display:flex;gap:12px;align-items:center;margin-bottom:12px">
          <div style="flex:1"><input type="text" id="search-input" placeholder="Enter Room ID to Create/Search"></div>
          <div style="width:160px"><button id="search-btn" class="btn-primary" style="width:100%">Find or Create Room</button></div>
        </div>
        <h3 style="color:var(--text);margin-top:0">Active Rooms</h3>
        <div id="room-list-container">${listHtml}</div>
        <div style="margin-top:12px"><button id="delete-all-rooms-btn" class="btn-danger">Delete All Rooms (Admin)</button></div>
      `;
      try{
        const q = query(collection(db, ROOM_COLLECTION), limit(30));
        const snap = await getDocs(q);
        if(snap.empty) listHtml = '<p style="color:var(--text)">No active rooms. Create one above!</p>';
        else{
          listHtml = '';
          snap.forEach(docSnap=>{
            const rData = docSnap.data();
            const rId = docSnap.id;
            const pCount = Object.keys(rData.players || {}).length;
            const ownerPlayer = rData.players[rData.ownerId];
            const ownerCmdName = ownerPlayer?.commanderName || ownerPlayer?.commander || 'N/A';
            const ownerCmdImage = ownerPlayer?.commanderImageUrl || '';
  
            const ownerName = ownerPlayer?.name || 'Owner';

            // compute createdAt and time left until timeout
            let createdAtDate = null;
            if(rData.createdAt){
              if(typeof rData.createdAt.toDate === 'function') createdAtDate = rData.createdAt.toDate();
              else if(rData.createdAt instanceof Date) createdAtDate 
              = rData.createdAt;
              else if(typeof rData.createdAt === 'number') createdAtDate = new Date(rData.createdAt);
            }
            // prefer lastLifeChange for timeout baseline
            let baselineDate = null;
            if(rData.lastLifeChange){
              if(typeof rData.lastLifeChange.toDate === 'function') baselineDate = rData.lastLifeChange.toDate();
              else if(rData.lastLifeChange instanceof Date) baselineDate = rData.lastLifeChange;
              else if(typeof rData.lastLifeChange === 'number') baselineDate = new Date(rData.lastLifeChange);
            } else {
              baselineDate = createdAtDate;
            }
            let timeLeftText = 'N/A';
            if(baselineDate){
              const elapsedMinutes = (Date.now() - baselineDate.getTime()) / (1000*60);
              const minutesLeft = Math.max(0, TIMEOUT_MINUTES - elapsedMinutes);
              timeLeftText = formatTimeLeft(minutesLeft);
            }

            listHtml += `
              <div class="room-item" style="display:flex;justify-content:space-between;align-items:center;background-color:#121416;padding:12px;margin-bottom:8px;border-radius:8px;border:1px solid var(--dark-border)">
                <div class="room-info" style="flex:1">
                  <div style="display:flex;align-items:center;gap:12px">
                    <div style="font-weight:800;color:var(--text);min-width:160px">${rId}</div>
          
                    <div style="font-size:.9em;color:var(--muted)">${pCount} Player(s) • Owner: ${ownerName}</div>
                  </div>
                  <div style="font-size:.85em;color:var(--muted);margin-top:6px;display:flex;gap:12px;align-items:center">
                    <div>Commander: <strong style="color:var(--text)">${ownerCmdName}</strong></div>
                    <div>Created: <strong style="color:var(--text)">${createdAtDate ?
            createdAtDate.toLocaleString() : 'N/A'}</strong></div>
                    <div>Expires: <strong style="color:var(--text)">${timeLeftText}</strong></div>
                  </div>
                </div>
                <div style="margin-left:12px"><button class="join-btn btn-secondary" data-rid="${rId}" style="width:auto">Join</button></div>
              </div>
       
            `;
          });
        }
      }catch(e){
        console.error("List error:",e);
        listHtml = `<p style="color:#ff5555">Error loading rooms. Permissions might be initializing...</p>`;
      }

      const listContainer = document.getElementById("room-list-container");
      if(listContainer) listContainer.innerHTML = listHtml;

      if(listContainer){
        listContainer.querySelectorAll('.join-btn').forEach(btn=>{
          btn.addEventListener('click', (e)=> promptPassword(e.target.dataset.rid, 'join'));
        });
        const previewCardEl = document.getElementById('lobby-card-preview');
        const previewImgEl = document.getElementById('preview-img');

        listContainer.querySelectorAll('.lobby-cmd-name').forEach(cmdSpan=>{
          const imageUrl = cmdSpan.dataset.imgUrl;
          cmdSpan.addEventListener('mouseenter', ()=>{
            if(imageUrl && previewCardEl && previewImgEl){ previewImgEl.src = imageUrl; previewCardEl.style.display = 'block'; }
          });
          cmdSpan.addEventListener('mouseleave', ()=>{
            if(previewCardEl){ previewCardEl.style.display = 'none'; previewImgEl.src = ''; }
     
          });
        });
      }

      document.getElementById("search-btn").onclick = async ()=>{
        const val = document.getElementById("search-input").value.trim().toLowerCase();
        if(!val) return;
        const snap = await getDoc(doc(db, ROOM_COLLECTION, val));
        if(snap.exists()) promptPassword(val,'join'); else promptPassword(val,'create');
      };

      document.getElementById("delete-all-rooms-btn").addEventListener('click', deleteAllRooms);
    }

    // ----------------------------------------------------------------------
    // ROOM VIEW
    // ----------------------------------------------------------------------
    function renderChat(chatLog, playerName){
      const chatLogDiv = document.getElementById('chat-log');
      if(!chatLogDiv) return;
      chatLogDiv.innerHTML = '';
      const displayLog = (chatLog || []).slice(-500);
      displayLog.forEach(msg=>{
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('chat-message');
        const senderSpan = document.createElement('span');
        senderSpan.classList.add('chat-sender');
        if(msg.senderName === 'System'){ senderSpan.classList.add('system'); senderSpan.textContent = 'System:'; }
        else senderSpan.textContent = `${msg.senderName}:`;
        messageDiv.appendChild(senderSpan);
        if(msg.cardImageUrl){
          const cardSpan = document.createElement('span');
       
          cardSpan.classList.add('chat-card');
          cardSpan.textContent = ` ${msg.message} `;
          cardSpan.dataset.cardImageUrl = msg.cardImageUrl;
          cardSpan.dataset.cardName = msg.message;
          messageDiv.appendChild(cardSpan);
          cardSpan.addEventListener('mouseenter', (e)=>{ showChatCardPreview(cardSpan.dataset.cardImageUrl, cardSpan.dataset.cardName); });
          cardSpan.addEventListener('mouseleave', (e)=>{ hideChatCardPreviewWithDelay();
          });
          cardSpan.addEventListener('click', (e)=>{ const preview = document.getElementById('chat-card-preview'); if(preview.style.display === 'block') hideChatCardPreviewImmediate(); else showChatCardPreview(cardSpan.dataset.cardImageUrl, cardSpan.dataset.cardName); });
        } else {
          messageDiv.appendChild(document.createTextNode(' ' + msg.message));
        }
        chatLogDiv.appendChild(messageDiv);
      });
      chatLogDiv.scrollTop = chatLogDiv.scrollHeight;
    }

    let chatPreviewHideTimer = null;
    function showChatCardPreview(imageUrl, title){
      if(chatPreviewHideTimer){ clearTimeout(chatPreviewHideTimer);
      chatPreviewHideTimer = null; }
      const preview = document.getElementById('chat-card-preview');
      const img = document.getElementById('chat-preview-img');
      const t = document.getElementById('chat-preview-title');
      img.src = imageUrl; t.textContent = title; preview.style.display = 'block';
    }
    function hideChatCardPreviewWithDelay(){ if(chatPreviewHideTimer) clearTimeout(chatPreviewHideTimer); chatPreviewHideTimer = setTimeout(()=>{ hideChatCardPreviewImmediate(); }, 300);
    }
    function hideChatCardPreviewImmediate(){ const preview = document.getElementById('chat-card-preview'); const img = document.getElementById('chat-preview-img'); const t = document.getElementById('chat-preview-title');
      preview.style.display = 'none'; img.src = ''; t.textContent = ''; if(chatPreviewHideTimer){ clearTimeout(chatPreviewHideTimer); chatPreviewHideTimer = null;
    } }

    function renderRoomView(roomData){
      const appContainer = document.getElementById("app-container");
      const statusMessage = document.getElementById("status-message");
      document.getElementById('lobby-card-preview').style.display = 'none';
      document.getElementById('card-search-modal').style.display = 'none';
      const currentPlayerName = roomData.players[userId]?.name || 'You';
      statusMessage.innerHTML = `Connected as: <strong>${currentPlayerName}</strong>`;
      // header + controls (roll moved left of Card Search; roll result shown left of button)
      let html = `
        <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px">
          <div style="display:flex;align-items:center;gap:8px">
            <div id="roll-result-top" style="font-size:1.5rem;font-weight:700;color:var(--accent);min-width:32px;text-align:center">-</div>
            <button id="roll-d20-btn-top" class="btn-secondary" style="width:100px;background:#444;color:#fff;font-size:.85rem;padding:8px">Roll D20</button>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="card-search-btn" class="btn-secondary">Card Search</button>
            <button id="restart-btn" class="btn-danger">Restart Game</button>
            <button id="leave-btn" class="btn-secondary">Leave Room</button>
          </div>
        </div>
        <div class="player-grid">
      `;

      const players = roomData.players || {};
      const playerIds = Array.isArray(roomData.playersOrder) && roomData.playersOrder.length ? roomData.playersOrder : Object.keys(players);
      
      // Ensure all current players are in playersOrder for consistency (hotfix for old rooms)
      const currentKeys = Object.keys(players);
      currentKeys.forEach(key => { if (!playerIds.includes(key)) playerIds.push(key); });


      playerIds.forEach(playerId => {
        const player = players[playerId];
        if(!player) return;

        const lifeVal = player.life ?? getStartingLife();
        const infectVal = player.infect ?? 0;
        const isMe = playerId === userId;

        const cmdBlockInner = isMe 
          ? `<div class="cmd-label">CMD DMG Out:</div><div class="cmd-value" id="outgoing-cmd-total">${computeOutgoingTotal(roomData, playerId)}</div>`
          : `<div class="cmd-label">CMD DMG In:</div><div class="cmd-value" id="incoming-cmd-total">${computeIncomingCmdDamage(roomData, playerId)}</div>`;


        // Check if CMD controls should be open
        if(!openCmdControls.has(playerId) && isMe) openCmdControls.add(playerId); // always open self-panel
        if(openCmdControls.has(playerId) && !isMe) openCmdControls.delete(playerId); // hide others on render

        const cmdControlsClass = openCmdControls.has(playerId) ? 'cmd-controls open' : 'cmd-controls';

        // per-opponent list for toggled cmd-controls
        let perOppRows = '';
        const opponents = playerIds.filter(id => id !== playerId);
        if(opponents.length > 0){
          opponents.forEach(oppId => {
            // value is opponent's outgoing to this player
            const dmg = (roomData.players[oppId]?.commanderDamage || {})[playerId] || 0;
            const oppName = roomData.players[oppId]?.name || 'Player';
            // only allow editing these incoming values if the target player is you (playerId === userId)
            const editable = (playerId === userId);
            const disabledAttr = editable ? '' : 'disabled';
            perOppRows += `
              <div class="per-opp-row" data-target="${playerId}" data-opp="${oppId}">
                <div class="per-opp-left">From <strong>${oppName}</strong></div>
                <div class="per-opp-controls">
                  <button class="control-btn negative small-btn" data-action="cmd-target-sub" data-target="${playerId}" data-opp="${oppId}" ${disabledAttr}>-</button>
                  <input type="number" value="${dmg}" data-target="${playerId}" data-opp="${oppId}" class="cmd-target-input" style="width:64px;padding:6px;border-radius:6px;border:1px solid var(--dark-border);background:var(--input-bg);color:var(--text);text-align:center" ${disabledAttr}>
                  <button class="control-btn negative small-btn" data-action="cmd-target-add" data-target="${playerId}" data-opp="${oppId}" ${disabledAttr}>+</button>
                </div>
              </div>
            `;
          });
        }
        // Infect controls (compact, next to value) - only allow editing your own infect
        const infectControlsHtml = `
          <div style="display:flex;align-items:center;gap:6px">
            <button class="control-btn small-btn" data-action="infect-sub" data-player="${playerId}" ${isMe ?
            '' : 'disabled'}>-</button>
            <div class="infect-value" id="infect-${playerId}">${infectVal}</div>
            <button class="control-btn small-btn" data-action="infect-add" data-player="${playerId}" ${isMe ? '' : 'disabled'}>+</button>
          </div>
        `;
        // For the CMD block: show "to" and "from" but hide "from" on YOU panel (per request).
        
        const outgoingTotal = computeOutgoingTotal(roomData, playerId);
        const incomingTotal = computeIncomingCmdDamage(roomData, playerId);

        let outgoingBreakdownHtml = '';
        if(isMe){
          const outgoing = computeOutgoingCmdDamage(roomData, playerId);
          let outgoingHtml = '<div class="outgoing-cmd-list">';
          if(outgoing.length === 0) outgoingHtml += `<div class="outgoing-cmd-item" style="justify-content:center;color:var(--muted)">No opponents yet</div>`;
          else {
            outgoing.forEach(item=>{
              outgoingHtml += `<div class="outgoing-cmd-item"><div style="font-weight:700">To ${item.oppName}:</div><div style="font-weight:900">${item.dmg}</div></div>`;
            });
          }
          outgoingHtml += '</div>';
          outgoingBreakdownHtml = `
            <div style="margin-top:10px;border-top:1px solid rgba(255,255,255,0.02);padding-top:8px">
              <div style="font-size:0.85rem;color:var(--muted);font-weight:700">Commander Damage Breakdown</div>
              ${outgoingHtml}
            </div>
          `;
        }

        html += `
          <div class="player-panel" data-player-id="${playerId}">
            <div class="player-header">
              <div class="player-info">
                <div class="player-name">${player.name}${isMe ? ' <span class="you-badge">YOU</span>' : ''}</div>
                <div class="player-sub">${player.commanderName || 'No Commander Set'}</div>
              </div>
              <div class="life-big" id="life-${playerId}">${lifeVal}</div>
            </div>
            <div style="display:flex;justify-content:space-between;gap:12px">
              <div style="flex:1">
                <div class="cmd-block">
                  <div class="cmd-label">${isMe ? 'CMD DMG Out:' : 'CMD DMG In:'}</div>
                  <div class="cmd-value">${isMe ? outgoingTotal : incomingTotal}</div>
                </div>
                <div class="infect-block" style="margin-top:8px">
                  <div class="infect-label">Infect:</div>
                  ${infectControlsHtml}
                </div>
                ${isMe ? outgoingBreakdownHtml : ''}
              </div>
              <div style="min-width:220px;display:flex;flex-direction:column;gap:8px;align-items:flex-end">
                <div class="controls" style="flex-direction:column;width:100%">
                  <div style="display:flex;gap:8px;width:100%">
                    <button class="control-btn negative" data-action="life" data-player="${playerId}" data-delta="-5" ${isMe ?
                    '' : 'disabled'}>-5</button>
                    <button class="control-btn negative" data-action="life" data-player="${playerId}" data-delta="-1" ${isMe ?
                    '' : 'disabled'}>-1</button>
                    <button class="control-btn positive" data-action="life" data-player="${playerId}" data-delta="+1" ${isMe ?
                    '' : 'disabled'}>+1</button>
                    <button class="control-btn positive" data-action="life" data-player="${playerId}" data-delta="+5" ${isMe ?
                    '' : 'disabled'}>+5</button>
                  </div>
                  <div style="display:flex;gap:8px;width:100%">
                    <button class="control-btn" data-action="cmd-toggle" data-player="${playerId}">CMD DMG</button>
                    ${!isMe ?
                    `<button class="control-btn preview" data-action="show-commander" data-player="${playerId}">Show CMD</button>` : ''}
                    ${isMe ?
                    `<button class="control-btn" data-action="edit-commander" data-player="${playerId}">Edit Commander</button>` : ''}
                  </div>
                </div>
              </div>
            </div>
            <div class="cmd-controls" id="cmd-controls-${playerId}">
              <div style="display:flex;flex-direction:column;gap:8px">
                <div style="font-weight:700;color:var(--muted);font-size:0.9em">Edit this player's commander damage values</div>
                <div class="per-opp-container" id="per-opp-${playerId}">
                  ${perOppRows}
                </div>
              </div>
            </div>
          </div>
        `;
      });

      html += `</div>`; // player-grid

      // Chat full width below player grid
      html += `
        <div id="chat-container">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <div style="font-weight:700;color:var(--text)">Game Chat</div>
            <div style="color:var(--muted);font-size:.85rem">Room ID: ${roomId}</div>
          </div>
          <div id="chat-log"></div>
          <form id="chat-input-form" style="display:flex;gap:8px;margin-top:8px">
            <input type="text" id="chat-message-input" placeholder="Type a message or card name (e.g., Sol Ring)" style="flex:1">
            <button class="btn-primary" style="min-width:100px">Send</button>
          </form>
        </div>
      `;

      // Room footer
      html += `
        <div id="room-footer">
          <div class="muted">Joined with ID: ${userId}</div>
          <div class="muted" id="activity-status">Active</div>
        </div>
      `;

      appContainer.innerHTML = html;
      renderChat(roomData.chatLog, currentPlayerName);

      // wiring
      document.getElementById('leave-btn').addEventListener('click', leaveRoom);
      document.getElementById('restart-btn').addEventListener('click', restartGame);

      // general button wiring
      document.querySelectorAll('.control-btn, .preview').forEach(btn => {
        btn.addEventListener('click', async () => {
          const action = btn.dataset.action;
          const targetPlayer = btn.dataset.player;
          if(action === 'life'){
            await updateLifeForPlayer(targetPlayer, parseInt(btn.dataset.delta));
          } else if(action === 'cmd-toggle'){
            const cmdControls = document.getElementById(`cmd-controls-${targetPlayer}`);
            if(cmdControls){
              if(cmdControls.classList.contains('open')){
                cmdControls.classList.remove('open');
                openCmdControls.delete(targetPlayer);
              } else {
                cmdControls.classList.add('open');
                openCmdControls.add(targetPlayer);
              }
            }
          } else if(action === 'show-commander'){
            showChatCardPreview(roomData.players[targetPlayer]?.commanderImageUrl, roomData.players[targetPlayer]?.commanderName);
            // Hide on next click/mouseout handled by card wiring
          } else if(action === 'edit-commander'){
            const currentName = roomData.players[targetPlayer]?.commanderName || roomData.players[targetPlayer]?.commander || '';
            openEditCommanderModal(currentName);
          } else if(action === 'cmd-target-add'){
            const t = btn.dataset.target;
            const opp = btn.dataset.opp;
            await updateCmdDamageForTarget(opp, t, +1);
          } else if(action === 'cmd-target-sub'){
            const t = btn.dataset.target;
            const opp = btn.dataset.opp;
            await updateCmdDamageForTarget(opp, t, -1);
          } else if(action === 'infect-add'){
            const t = btn.dataset.player;
            await updateInfect(t, +1);
          } else if(action === 'infect-sub'){
            const t = btn.dataset.player;
            await updateInfect(t, -1);
          }
        });
      });

      // inputs for direct edits (opp -> target)
      document.querySelectorAll('.cmd-target-input').forEach(input => {
        input.addEventListener('change', async (e) => {
          if (input.disabled) return;
          const target = input.dataset.target;
          const opp = input.dataset.opp;
          const val = parseInt(input.value) || 0;
          await updateCmdDamageForTargetDirectly(opp, target, val);
        });
      });

      // chat submit
      const chatForm = document.getElementById('chat-input-form');
      if(chatForm){
        chatForm.addEventListener('submit', (e)=>{
          e.preventDefault();
          const input = document.getElementById('chat-message-input');
          const message = input.value.trim();
          if(message){
            sendChatMessage(message, currentPlayerName);
            input.value = '';
          }
        });
      }

      // roll dice top button wiring (MODIFIED TO POST TO CHAT)
      const rollBtnTop = document.getElementById('roll-d20-btn-top');
      const rollResultTop = document.getElementById('roll-result-top');
      // Get the current player's name from the room data
      const playerName = roomData.players[userId]?.name || 'You';

      if(rollBtnTop){
        rollBtnTop.addEventListener('click', ()=>{
          const roll = Math.floor(Math.random()*20)+1;
          rollResultTop.textContent = roll;

          // POST D20 ROLL RESULT TO CHAT
          const systemMessage = `${playerName} rolled a ${roll}!`;
          postSystemMessage(systemMessage);
        });
      }

      // card search modal wiring
      document.getElementById('card-search-btn').addEventListener('click', ()=>{
        const modal = document.getElementById('card-search-modal');
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden','false');
        document.getElementById('modal-card-name').value = '';
        document.getElementById('search-results').innerHTML = '';
      });
      document.getElementById('modal-close-btn').addEventListener('click', ()=>{
        const modal = document.getElementById('card-search-modal');
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden','true');
      });
      document.getElementById('modal-card-name').addEventListener('input', (e)=>{
        if(autocompleteTimeout) clearTimeout(autocompleteTimeout);
        autocompleteTimeout = setTimeout(()=>fetchAutocompleteSuggestions(e.target.value, 'modal-suggestions-list', 'modal-card-name'), AUTOCOMPLETE_DEBOUNCE_MS);
      });
      document.getElementById('modal-search-btn').addEventListener('click', async ()=>{
        const input = document.getElementById('modal-card-name');
        const resultsDiv = document.getElementById('search-results');
        const modal = document.getElementById('card-search-modal');
        const cardName = input.value.trim();
        if(!cardName) return;
        resultsDiv.innerHTML = `<p style="color:var(--muted)">Searching for "${cardName}"...</p>`;
        try{
          const response = await fetch(`${SCRYFALL_API}${encodeURIComponent(cardName)}`);
          const data = await response.json();
          if(response.ok){
            const imageUrl = data.image_uris?.normal || data.card_faces?.[0]?.image_uris?.normal;
            if(imageUrl){
              postCardToChat(data.name, imageUrl);
              resultsDiv.innerHTML = `<p style="color:var(--green)">Posted "${data.name}" to chat.</p>`;
              setTimeout(()=>{ modal.style.display = 'none'; modal.setAttribute('aria-hidden','true'); }, 600);
            } else {
              resultsDiv.innerHTML = `<p style="color:var(--text)">Card found, but no image available. Not posting.</p>`;
            }
          } else {
            resultsDiv.innerHTML = `<p style="color:var(--text)">Card not found. Check spelling.</p>`;
          }
        }catch(e){
          resultsDiv.innerHTML = `<p style="color:var(--text)">Error connecting to Scryfall.</p>`;
          console.error(e);
        }
      });
    }

    // ----------------------------------------------------------------------
    // FIREBASE UPDATERS
    // ----------------------------------------------------------------------
    async function sendChatMessage(message, senderName){
      if(!roomId) return;
      const ref = doc(db, ROOM_COLLECTION, roomId);
      const chatMessage = {
        senderName,
        message,
        timestamp: Date.now()
      };

      // Check for card name match
      try{
        const response = await fetch(`${SCRYFALL_API}${encodeURIComponent(message)}`);
        const data = await response.json();
        if(response.ok){
          const imageUrl = data.image_uris?.normal || data.card_faces?.[0]?.image_uris?.normal;
          if(imageUrl){
            chatMessage.cardImageUrl = imageUrl;
            chatMessage.message = data.name; // Use canonical name
          }
        }
      }catch(e){
        // Ignore card search failure, post regular message
      }

      try{
        // Use arrayUnion to safely append the new message
        await setDoc(ref, { chatLog: arrayUnion(chatMessage), lastActive: serverTimestamp() }, { merge: true });
      } catch(e){
        console.error("Error sending chat message:", e);
      }
    }

    async function postCardToChat(cardName, imageUrl){
      if(!roomId) return;
      const ref = doc(db, ROOM_COLLECTION, roomId);
      const chatMessage = {
        senderName: 'System',
        message: cardName,
        cardImageUrl: imageUrl,
        timestamp: Date.now()
      };
      try{
        await setDoc(ref, { chatLog: arrayUnion(chatMessage), lastActive: serverTimestamp() }, { merge: true });
      } catch(e){
        console.error("Error posting system card to chat:", e);
      }
    }

    // Update life: only allow editing your own life.
    // Also update lastLifeChange timestamp so timeout resets.
    async function updateLifeForPlayer(targetPlayerId, delta){
      if(!roomId || !userId) return;
      if(targetPlayerId !== userId) return; // only allow editing your own life

      const ref = doc(db, ROOM_COLLECTION, roomId);
      try{
        const snap = await getDoc(ref);
        if(!snap.exists()) return;
        const data = snap.data();
        const players = data.players || {};
        const target = players[targetPlayerId] || {};
        const cur = target.life ?? getStartingLife();
        const newLife = cur + delta;
        target.life = newLife;
        // update lastLifeChange so timeout is based on life changes
        await setDoc(ref, { players: { [targetPlayerId]: target }, lastActive: serverTimestamp(), lastLifeChange: serverTimestamp() }, { merge: true });
      }catch(e){
        console.error("Error updating life for player:", e);
      }
    }

    // Infect update: only your own infect (does not affect lastLifeChange)
    async function updateInfect(targetPlayerId, delta){
      if(!roomId || !userId) return;
      if(targetPlayerId !== userId) return; // only allow editing your own infect
      const ref = doc(db, ROOM_COLLECTION, roomId);
      try{
        const snap = await getDoc(ref);
        if(!snap.exists()) return;
        const data = snap.data();
        const players = data.players || {};
        const target = players[targetPlayerId] || {};
        const cur = target.infect || 0;
        const newVal = Math.max(0, cur + delta);
        target.infect = newVal;
        await setDoc(ref, { players: { [targetPlayerId]: target }, lastActive: serverTimestamp() }, { merge: true });
      }catch(e){
        console.error("Error updating infect for player:", e);
      }
    }


    // update cmd: sourcePlayerId (ME) -> targetPlayerId (OPPONENT)
    async function updateCmdDamageForSource(sourcePlayerId, targetPlayerId, delta){
      if(!roomId || !userId) return;
      if(sourcePlayerId !== userId) return; // only allow editing your outgoing dmg

      const ref = doc(db, ROOM_COLLECTION, roomId);
      try{
        const snap = await getDoc(ref);
        if(!snap.exists()) return;
        const data = snap.data();
        const players = data.players || {};
        const source = players[sourcePlayerId] || {};

        const dmgMap = source.commanderDamage || {};
        const cur = dmgMap[targetPlayerId] || 0;
        const newDmg = Math.max(0, cur + delta); // damage can't be negative
        dmgMap[targetPlayerId] = newDmg;
        source.commanderDamage = dmgMap;

        await setDoc(ref, { players: { [sourcePlayerId]: source }, lastActive: serverTimestamp() }, { merge: true });
      }catch(e){
        console.error("Error updating commander damage for source (me -> opp):", e);
      }
    }

    // update cmd: oppId (OPPONENT) -> targetPlayerId (ME)
    async function updateCmdDamageForTarget(oppId, targetPlayerId, delta){
      if(!roomId || !userId) return;
      if(targetPlayerId !== userId) return; // only allow editing incoming dmg to you (which is opponent's outgoing)

      const ref = doc(db, ROOM_COLLECTION, roomId);
      try{
        const snap = await getDoc(ref);
        if(!snap.exists()) return;
        const data = snap.data();
        const players = data.players || {};
        const opponent = players[oppId] || {};

        const dmgMap = opponent.commanderDamage || {};
        const cur = dmgMap[targetPlayerId] || 0;
        const newDmg = Math.max(0, cur + delta);
        dmgMap[targetPlayerId] = newDmg;
        opponent.commanderDamage = dmgMap;

        await setDoc(ref, { players: { [oppId]: opponent }, lastActive: serverTimestamp() }, { merge: true });
      }catch(e){
        console.error("Error updating commander damage for target (opp -> me):", e);
      }
    }

    // direct set: oppId -> targetPlayerId = newValue
    async function updateCmdDamageForTargetDirectly(oppId, targetPlayerId, newValue){
      if(!roomId || !userId) return;
      if(targetPlayerId !== userId) return;

      const ref = doc(db, ROOM_COLLECTION, roomId);
      try{
        const snap = await getDoc(ref);
        if(!snap.exists()) return;
        const data = snap.data();
        const players = data.players || {};
        const opponent = players[oppId] || {};

        const dmgMap = opponent.commanderDamage || {};
        dmgMap[targetPlayerId] = Math.max(0, parseInt(newValue) || 0);
        opponent.commanderDamage = dmgMap;

        await setDoc(ref, { players: { [oppId]: opponent }, lastActive: serverTimestamp() }, { merge: true });
      }catch(e){
        console.error("Error setting commander damage for target directly (opp -> target):", e);
      }
    }

    // ----------------------------------------------------------------------
    // CHAT MESSAGE HELPERS
    // ----------------------------------------------------------------------
    /**
     * Posts a non-card message to the chat log from the System.
     * @param {string} message The message content.
     */
    async function postSystemMessage(message){
      if(!roomId) return;
      const ref = doc(db, ROOM_COLLECTION, roomId);
      const chatMessage = {
        senderName: 'System', // Force System sender
        message,
        timestamp: Date.now()
      };
      try{
        // Use arrayUnion to safely append the new message
        await setDoc(ref, { chatLog: arrayUnion(chatMessage), lastActive: serverTimestamp() }, { merge: true });
      } catch(e){
        console.error("Error posting system message to chat:", e);
      }
    }

    // ----------------------------------------------------------------------
    // RESTART GAME: reset life and clear commanderDamage and infect for all players
    // ----------------------------------------------------------------------
    async function restartGame(){
      if(!roomId) return;
      const ref = doc(db, ROOM_COLLECTION, roomId);
      try{
        const snap = await getDoc(ref);
        if(!snap.exists()) return;
        const data = snap.data();
        const players = data.players || {};
        const updates = {};
        Object.keys(players).forEach(pid=>{
          updates[pid] = { ...players[pid], life: getStartingLife(), commanderDamage: {}, infect: 0 };
        });
        // reset lastLifeChange to now so timeout restarts
        await setDoc(ref, { players: updates, lastActive: serverTimestamp(), lastLifeChange: serverTimestamp() }, { merge: true });
        alert("Game restarted: life reset, commander damage and infect cleared.");
      }catch(e){
        console.error("Failed to restart game:", e);
        alert("Failed to restart game. Check console.");
      }
    }

    // ----------------------------------------------------------------------
    // EDIT COMMANDER: modal flow
    // ----------------------------------------------------------------------
    function openEditCommanderModal(prefillName=''){
      const modal = document.getElementById('edit-commander-modal');
      modal.style.display = 'flex';
      modal.setAttribute('aria-hidden','false');
      document.getElementById('edit-commander-name').value = prefillName;
      document.getElementById('edit-commander-result').innerHTML = '';
      const input = document.getElementById('edit-commander-name');
      const suggestions = document.getElementById('edit-commander-suggestions');
      let editAutocompleteTimeout = null;

      function cleanup(){
        input.removeEventListener('input', onInput);
        document.getElementById('edit-commander-save').removeEventListener('click', saveHandler);
        document.getElementById('edit-commander-cancel').removeEventListener('click', cancelHandler);
      }

      function onInput(e){
        if(editAutocompleteTimeout) clearTimeout(editAutocompleteTimeout);
        editAutocompleteTimeout = setTimeout(()=>fetchAutocompleteSuggestions(e.target.value, 'edit-commander-suggestions', 'edit-commander-name'), AUTOCOMPLETE_DEBOUNCE_MS);
      }

      function cancelHandler(){
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden','true');
        cleanup();
      }

      input.addEventListener('input', onInput);
      document.getElementById('edit-commander-cancel').addEventListener('click', cancelHandler);

      const saveHandler = async ()=>{
        const commander = input.value.trim();
        const resultDiv = document.getElementById('edit-commander-result');
        if(!commander){ resultDiv.textContent = "Please enter a commander name."; return; }

        resultDiv.textContent = "Validating commander...";
        const validation = await validateCommander(commander);

        if(!validation){
          resultDiv.textContent = `Commander "${commander}" not found on Scryfall. Please check spelling.`;
          return;
        }

        try{
          const ref = doc(db, ROOM_COLLECTION, roomId);
          const snap = await getDoc(ref);
          if(!snap.exists()) return;
          const data = snap.data();
          const players = data.players || {};
          const me = players[userId] || {};
          me.commanderName = validation.validatedName;
          me.commanderImageUrl = validation.imageUrl;
          await setDoc(ref, { players: { [userId]: me }, lastActive: serverTimestamp() }, { merge: true });
          resultDiv.textContent = "Commander updated.";
          setTimeout(()=>{ modal.style.display = 'none'; modal.setAttribute('aria-hidden','true'); cleanup(); }, 700);
        }catch(e){
          console.error("Failed to save commander edit:", e);
          resultDiv.textContent = "Failed to save. Check console.";
        }
      };

      document.getElementById('edit-commander-save').addEventListener('click', saveHandler);
    }

    // ----------------------------------------------------------------------
    // ROOM CREATION / JOIN / LISTEN
    // ----------------------------------------------------------------------
    async function checkAndDeleteIfExpired(roomIdToCheck, roomData) {
      try {
        if (!roomData) return false;
        const lastLifeField = roomData.lastLifeChange || roomData.createdAt || roomData.lastActive;
        if (!lastLifeField) return false;

        let lastActiveDate = null;
        if (typeof lastLifeField.toDate === 'function') lastActiveDate = lastLifeField.toDate();
        else if (lastLifeField instanceof Date) lastActiveDate = lastLifeField;
        else if (typeof lastLifeField === 'number') lastActiveDate = new Date(lastLifeField);
        else return false;

        const elapsedMinutes = (Date.now() - lastActiveDate.getTime()) / (1000 * 60);

        if (elapsedMinutes > TIMEOUT_MINUTES) {
          try {
            await deleteDoc(doc(db, ROOM_COLLECTION, roomIdToCheck));
          } catch (e) {
            console.error("Failed to delete expired room:", e);
          }
          if (localStorage.getItem('currentRoomId') === roomIdToCheck) localStorage.removeItem('currentRoomId');
          return true;
        }
        return false;
      } catch (e) {
        console.error("checkAndDeleteIfExpired error:", e);
        return false;
      }
    }

    function promptPassword(rid, mode){
      const appContainer = document.getElementById("app-container");
      const title = mode === 'join' ?
        `Join Room: ${rid}` : `Create Room: ${rid}`;
      const btnText = mode === 'join' ? "Enter Game" : "Create Room";

      document.getElementById('lobby-card-preview').style.display = 'none';
      appContainer.innerHTML = `
        <h2 style="margin-top:0">${title}</h2>
        <input type="text" id="player-name" placeholder="Your Player Name (e.g., Planeswalker-1)" value="${localStorage.getItem('playerName') || ''}">
        <input type="password" id="room-password" placeholder="Room Password">
        <input type="text" id="commander-name" placeholder="Your Commander's Name">
        <div id="commander-suggestions" class="suggestions-list"></div>
        <p id="error-message" style="color:var(--red);font-weight:700;margin:10px 0 0 0"></p>
        <div style="display:flex;gap:8px;margin-top:10px;">
          <button id="action-btn" class="btn-primary" style="flex:1">${btnText}</button>
          <button id="cancel-btn" class="btn-secondary" style="min-width:100px">Cancel</button>
        </div>
      `;

      const input = document.getElementById('commander-name');
      let createAutocompleteTimeout = null;
      input.addEventListener('input', (e)=>{
        if(createAutocompleteTimeout) clearTimeout(createAutocompleteTimeout);
        createAutocompleteTimeout = setTimeout(()=>fetchAutocompleteSuggestions(e.target.value, 'commander-suggestions', 'commander-name'), AUTOCOMPLETE_DEBOUNCE_MS);
      });


      document.getElementById("cancel-btn").onclick = ()=>navigateTo('home');
      document.getElementById("action-btn").onclick = async ()=>{
        const name = document.getElementById("player-name").value.trim();
        const pwd = document.getElementById("room-password").value.trim();
        const commander = document.getElementById("commander-name").value.trim();
        const errMsg = document.getElementById("error-message");
        const actionBtn = document.getElementById("action-btn");

        localStorage.setItem('playerName', name);

        if(!name || !pwd || !commander){
          errMsg.textContent = "All fields are required.";
          return;
        }

        errMsg.textContent = "Validating commander and joining...";
        actionBtn.disabled = true;

        const validationResult = await validateCommander(commander);

        if(!validationResult){
          errMsg.textContent = `Commander "${commander}" not found on Scryfall. Please check spelling or use the Card Search tool.`;
          actionBtn.disabled = false;
          return;
        }

        const { validatedName, imageUrl } = validationResult;
        const ref = doc(db, ROOM_COLLECTION, rid);
        const snap = await getDoc(ref);

        if(mode === 'join'){
          if(snap.exists()){
            const data = snap.data();
            if (await checkAndDeleteIfExpired(rid, data)) {
              errMsg.textContent = "Room expired and was deleted.";
              actionBtn.disabled = false;
              setTimeout(()=> navigateTo('home'),2000);
              return;
            }

            if(data.passwordHash === hashPassword(pwd)){
              try {
                const playerObj = { life: getStartingLife(), commanderDamage: {}, infect: 0, name, commanderName: validatedName, commanderImageUrl: imageUrl };
                await updateDoc(ref, { ['players.' + userId]: playerObj, playersOrder: arrayUnion(userId), lastActive: serverTimestamp() });
                localStorage.setItem('currentRoomId', rid);
                listenToRoom(rid);
              } catch (e) {
                console.error("Failed to add joining player:", e);
                errMsg.textContent = "Failed to join room. Try again.";
                actionBtn.disabled = false;
              }
            } else {
              errMsg.textContent = "Wrong password.";
              actionBtn.disabled = false;
            }
          } else {
            errMsg.textContent = "Room no longer exists.";
            actionBtn.disabled = false;
          }
        } else {
          if(pwd.length < 3){
            errMsg.textContent = "Password too short.";
            actionBtn.disabled = false;
            return;
          }
          try {
            await createRoom(rid, pwd, name, validatedName, imageUrl);
            localStorage.setItem('currentRoomId', rid);
          } catch (e) {
            console.error("Create room failed:", e);
            errMsg.textContent = "Failed to create room. Try again.";
            actionBtn.disabled = false;
          }
        }
      };
    }

    async function createRoom(rid, pwd, name, commanderName, commanderImageUrl){
      if(!userId) return;
      const ref = doc(db, ROOM_COLLECTION, rid);
      try{
        await setDoc(ref, {
          ownerId: userId,
          passwordHash: hashPassword(pwd),
          createdAt: serverTimestamp(),
          lastActive: serverTimestamp(),
          lastLifeChange: serverTimestamp(),
          chatLog: [],
          playersOrder: [userId],
          players: {
            [userId]: { life: getStartingLife(), commanderDamage: {}, infect: 0, name, commanderName, commanderImageUrl }
          }
        });
        listenToRoom(rid);
      }catch(e){
        if(e.code === 'PERMISSION_DENIED'){
          alert("Permission denied. You may not have permission to create this room, or the Room ID may be restricted.");
        }
        throw e;
      }
    }

    async function listenToRoom(rid){
      if(unsubscribe) unsubscribe(); // cleanup old listener
      roomId = rid;
      openCmdControls.clear();

      const docRef = doc(db, ROOM_COLLECTION, rid);
      unsubscribe = onSnapshot(docRef, async docSnap => {
        if (docSnap.exists()){
          const roomData = docSnap.data();
          const expired = await checkAndDeleteIfExpired(rid, roomData);
          if (expired) {
            alert(`Room ${rid} expired due to inactivity and was deleted.`);
            if(unsubscribe) unsubscribe();
            navigateTo('home');
            return;
          }
          if(roomData.players?.[userId]){
            renderRoomView(roomData);
            const status = document.getElementById('activity-status');
            if(status) {
              const lastActive = roomData.lastActive?.toDate() || new Date();
              const diff = Date.now() - lastActive.getTime();
              status.textContent = `Last activity: ${Math.round(diff/1000)}s ago`;
            }
          } else {
            // Player was removed or room was just created but not fully populated yet
            if(roomData.players && Object.keys(roomData.players).length > 0){
              alert("You have been removed from the room.");
            } else {
              alert("The room was emptied and deleted.");
            }
            if(unsubscribe) unsubscribe();
            localStorage.removeItem('currentRoomId');
            navigateTo('home');
          }
        } else {
          alert("Room no longer exists.");
          if(unsubscribe) unsubscribe();
          localStorage.removeItem('currentRoomId');
          navigateTo('home');
        }
      }, error=>{
        console.error("Snapshot error:", error);
        alert("Lost connection to the room.");
        if(unsubscribe) unsubscribe();
        localStorage.removeItem('currentRoomId');
        navigateTo('home');
      });
    }

    function leaveRoom(){
      if(!roomId) return;
      if(!confirm("Are you sure you want to leave the room? Your player will be removed.")) return;

      const ref = doc(db, ROOM_COLLECTION, roomId);
      try{
        // Remove player from the players map
        updateDoc(ref, {
          [`players.${userId}`]: deleteField(),
          lastActive: serverTimestamp()
        }).then(()=>{
          if(unsubscribe) unsubscribe();
          roomId = null;
          localStorage.removeItem('currentRoomId');
          navigateTo('home');
        }).catch(e=>{
          console.error("Failed to remove player:", e);
          alert("Failed to leave room. Check console.");
        });

      }catch(e){
        console.error("Error leaving room:", e);
        alert("Failed to leave room. Check console.");
      }
    }

    async function deleteAllRooms(){
      const password = prompt("Enter the global deletion password to confirm this action:");
      if(password !== DELETE_ALL_PWD){
        alert("Incorrect password. All rooms were NOT deleted.");
        return;
      }
      if(!confirm("LAST WARNING: Are you absolutely sure you want to delete ALL rooms? This cannot be undone?")) return;
      document.getElementById("status-message").textContent = "Deleting all rooms...";

      const roomsRef = collection(db, ROOM_COLLECTION);
      try{
        const snapshot = await getDocs(roomsRef);
        let deleteCount = 0;
        for(const docSnapshot of snapshot.docs){
          await deleteDoc(doc(db, ROOM_COLLECTION, docSnapshot.id));
          deleteCount++;
        }
        alert(`Success! Deleted ${deleteCount} room(s).`);
        renderSetupView();
      }catch(e){
        console.error("Failed to delete all rooms:", e);
        alert("An error occurred during bulk deletion. Check the console.");
      }
    }

    async function deleteRoom(id){
      if(!id) return;
      try{
        await deleteDoc(doc(db, ROOM_COLLECTION, id));
        if(unsubscribe) unsubscribe();
        roomId = null;
        renderSetupView();
      } catch(e){
        alert("Failed to delete room. Check console for details.");
        console.error("Delete room failed:", e);
      }
    }

    // ----------------------------------------------------------------------
    // INIT: auth + initial route + persist join on refresh
    // ----------------------------------------------------------------------
    function initialRoute(){
      const params = new URLSearchParams(window.location.search);
      const idFromURL = params.get('roomID');
      const persistedRoom = localStorage.getItem('currentRoomId');

      if(idFromURL){ promptPassword(idFromURL,'join'); setActiveNav('home'); return; }

      if(persistedRoom){ listenToRoom(persistedRoom); setActiveNav('home'); return; }

      const page = (location.hash || '#home').replace('#','') || 'home';
      setActiveNav(page);
      if(page === 'home') renderHome();
      else if(page === 'changes') renderChanges();
      else if(page === 'contact') renderContact();
    }

    onAuthStateChanged(auth, user=>{
      if(user){ userId = user.uid; initialRoute(); }
      else{ signInAnonymously(auth).catch(e=>{ document.getElementById("status-message").textContent = "Auth Error: " + e.message; }); }
    });
  </script>
</body>
</html>
