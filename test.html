<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MTG Life Tracker</title>
  <style>
    :root{
      --bg:#0f1113;--card:#16181a;--muted:#9aa3ad;--text:#e6eef6;
      --accent:#2980b9;--accent-strong:#1f6fa8;--green:#27ae60;--red:#c0392b;
      --dark-border:#22272a;--input-bg:#1f2326;
    }
    html,body{height:100%;margin:0}
    body{
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background:var(--bg);color:var(--text);display:flex;flex-direction:column;
      align-items:center;padding:20px;box-sizing:border-box;min-height:100vh;
    }
    header.app-header{width:100%;max-width:1100px;display:flex;justify-content:space-between;align-items:center;margin-bottom:18px;gap:12px}
    .brand{display:flex;flex-direction:column;gap:2px}
    .app-title{margin:0;font-size:1.25rem;color:var(--text)}
    .app-subtitle{margin:0;font-size:0.8rem;color:var(--muted);font-style:italic}
    nav.site-nav{display:flex;gap:8px}
    nav.site-nav button{background:transparent;color:var(--text);border:1px solid transparent;padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600}
    nav.site-nav button.active{background:rgba(41,128,185,0.10);border-color:var(--accent)}
    #app-container{width:100%;max-width:1100px;background:var(--card);padding:20px;border-radius:12px;box-shadow:0 6px 30px rgba(0,0,0,0.6);box-sizing:border-box;position:relative}
    input,textarea,select{width:100%;padding:12px;margin-bottom:10px;border-radius:8px;border:1px solid var(--dark-border);background:var(--input-bg);color:var(--text);box-sizing:border-box}
    textarea{min-height:120px;resize:vertical}
    input,button,textarea,select{-webkit-appearance:none;appearance:none;-webkit-tap-highlight-color:transparent}
    *:focus,*:focus-visible,*:focus-within{outline:none!important;box-shadow:none!important}
    button{cursor:pointer;border-radius:8px;padding:10px 12px;border:none;font-weight:700;transition:transform .08s ease,opacity .12s}
    button:active,.tapped{transform:scale(.96)}
    .btn-primary{background:linear-gradient(180deg,var(--green),#1f8a4a);color:#fff}
    .btn-danger{background:linear-gradient(180deg,var(--red),#9b2b24);color:#fff}
    .btn-secondary{background:linear-gradient(180deg,#3a3a3a,#2f2f2f);color:#fff}
    button:disabled, input:disabled { opacity: .45; cursor: not-allowed; filter: grayscale(.2); }
    .player-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:16px;margin-top:12px}
    @media(max-width:900px){.player-grid{grid-template-columns:1fr}}
    .player-panel{background:linear-gradient(180deg,rgba(255,255,255,0.01),rgba(255,255,255,0.00));border:1px solid var(--dark-border);border-radius:12px;padding:14px;display:flex;flex-direction:column;gap:10px;position:relative;box-shadow:0 6px 18px rgba(0,0,0,0.6)}
    .player-header{display:flex;justify-content:space-between;align-items:center;gap:8px}
    .player-name{font-weight:800;font-size:1rem;color:var(--text)}
    .player-sub{font-size:.85rem;color:var(--muted)}
    .life-big{font-size:3.2rem;font-weight:900;color:var(--text);letter-spacing:-1px}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    .control-btn{padding:8px 12px;border-radius:8px;font-weight:800;min-width:56px;text-align:center;background:linear-gradient(180deg,#2b2b2b,#232323);color:var(--text);border:1px solid rgba(255,255,255,0.03);cursor:pointer;display:inline-flex;align-items:center;justify-content:center}
    .control-btn.positive{background:linear-gradient(180deg,#2ecc71,#27ae60);color:#04260a}
    .control-btn.negative{background:linear-gradient(180deg,#ff6b6b,#c0392b);color:#2b0706}
    .cmd-block{display:flex;justify-content:space-between;align-items:center;gap:8px;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    .cmd-label{font-size:.9rem;color:var(--muted)}
    .cmd-value{font-weight:800;color:#ffb3b3}
    .you-badge{background:linear-gradient(90deg,var(--accent),var(--accent-strong));color:#fff;padding:6px 8px;border-radius:999px;font-weight:800;font-size:.8rem}
    .cmd-controls{display:none;margin-top:10px}
    .cmd-controls.open{display:block}
    .per-opp-container{margin-top:10px;display:flex;flex-direction:column;gap:6px;max-height:160px;overflow:auto;border-top:1px solid rgba(255,255,255,0.02);padding-top:8px}
    .per-opp-row{height:44px;display:flex;justify-content:space-between;align-items:center;gap:8px;padding:6px 8px;border-radius:8px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02);box-sizing:border-box}
    .per-opp-left{font-size:0.9em;color:var(--muted);font-weight:700}
    .per-opp-controls{display:flex;align-items:center;gap:8px}
    .outgoing-cmd-list{display:flex;flex-direction:column;gap:6px;margin-top:8px}
    .outgoing-cmd-item{font-size:0.95rem;color:var(--text);display:flex;justify-content:space-between;align-items:center;padding:6px 8px;border-radius:6px;background:rgba(255,255,255,0.01);border:1px solid rgba(255,255,255,0.02)}
    .infect-block{margin-top:8px;display:flex;align-items:center;gap:8px}
    .infect-label{font-size:0.85rem;color:var(--muted)}
    .infect-value{font-weight:800;color:#bfe6a8;min-width:36px;text-align:center}
    .small-btn{padding:6px 8px;font-size:0.85rem;min-width:36px;border-radius:6px}
    #chat-log{height:150px;overflow-y:auto;border:1px solid rgba(255,255,255,0.03);padding:10px;margin-bottom:10px;border-radius:8px;background:#0f1113;font-size:.9em}
    .chat-message{margin-bottom:6px;display:flex;gap:8px;align-items:center}
    .chat-sender{font-weight:800;color:#74b9ff;margin-right:6px}
    .chat-sender.system{color:#ffd166;font-weight:900}
    .chat-card{display:inline-block;position:relative;cursor:pointer;color:var(--text);text-decoration:underline dotted rgba(255,255,255,0.08)}
    #chat-card-preview{position:fixed;top:50%;right:20px;transform:translateY(-50%);width:300px;max-width:40vw;border:3px solid var(--accent);border-radius:10px;box-shadow:0 12px 40px rgba(0,0,0,0.7);background:#0b0d0f;z-index:1500;display:none;padding:8px}
    #chat-card-preview img{display:block;width:100%;border-radius:6px}
    #chat-card-preview .card-title{margin-top:8px;font-weight:800;color:var(--text);text-align:center}
    .modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.6);display:none;justify-content:center;align-items:center;z-index:2000}
    .modal-content{background:#16181a;color:var(--text);padding:20px;border-radius:10px;width:92%;max-width:520px;box-shadow:0 12px 40px rgba(0,0,0,0.7);position:relative}
    .suggestions-list{position:absolute;width:100%;background:var(--input-bg);border:1px solid var(--dark-border);border-top:none;max-height:150px;overflow-y:auto;z-index:100;border-radius:0 0 8px 8px;box-shadow:0 6px 18px rgba(0,0,0,0.6);margin-top:-10px}
    .suggestions-list:empty{display:none!important;border:none!important;box-shadow:none!important;margin-top:0!important}
    .suggestion-item{padding:8px 12px;cursor:pointer;color:var(--text)}
    .suggestion-item:hover{background:rgba(41,128,185,.08)}
    #lobby-card-preview{position:fixed;top:50%;left:20px;transform:translateY(-50%);width:260px;border:3px solid var(--accent);border-radius:10px;box-shadow:0 8px 30px rgba(0,0,0,0.8);z-index:999;display:none;background:#0b0d0f}
    #lobby-card-preview img{display:block;width:100%;border-radius:6px}
    #lobby-features{margin-top:18px;display:flex;gap:12px;align-items:center;flex-wrap:wrap}
    #room-footer{margin-top:14px;color:var(--muted);font-size:.9rem;display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
    .muted{color:var(--muted)}
    .row{display:flex;gap:8px;align-items:center}
    .col{display:flex;flex-direction:column;gap:8px}
    @media(max-width:720px){header.app-header{flex-direction:column;align-items:flex-start;gap:8px}#lobby-card-preview{display:none!important}#chat-card-preview{display:none!important}}
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.2.0/crypto-js.min.js"></script>
</head>
<body>
  <header class="app-header" role="banner">
    <div class="brand">
      <h1 class="app-title">Cardboard Bonfire</h1>
      <div class="app-subtitle">Life tracker for keeping life and bringing people together.</div>
    </div>
    <nav class="site-nav" role="navigation" aria-label="Main">
      <button id="nav-home" class="nav-btn">Home</button>
      <button id="nav-changes" class="nav-btn">Changes</button>
      <button id="nav-contact" class="nav-btn">Contact</button>
    </nav>
  </header>

  <main id="app-container" role="main"></main>

  <div id="lobby-card-preview" aria-hidden="true"><img id="preview-img" alt="Commander Preview"></div>
  <div id="chat-card-preview" aria-hidden="true"><img id="chat-preview-img" alt="Card Preview"><div class="card-title" id="chat-preview-title"></div></div>
  <p id="status-message" class="muted">Initializing...</p>

  <div id="card-search-modal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <h3 style="margin-top:0">Card Search (Scryfall)</h3>
      <input type="text" id="modal-card-name" placeholder="Enter card name" autocomplete="off">
      <div id="modal-suggestions-list" class="suggestions-list"></div>
      <div style="display:flex;gap:8px;margin-top:10px;">
        <button id="modal-search-btn" class="btn-primary">Search & Post</button>
        <button id="modal-close-btn" class="btn-secondary">Close</button>
      </div>
      <div id="search-results" style="margin-top:12px"></div>
    </div>
  </div>

  <div id="edit-commander-modal" class="modal" aria-hidden="true">
    <div class="modal-content">
      <h3 style="margin-top:0">Edit Commander</h3>
      <input type="text" id="edit-commander-name" placeholder="Commander name">
      <div id="edit-commander-suggestions" class="suggestions-list"></div>
      <div style="display:flex;gap:8px;margin-top:10px;">
        <button id="edit-commander-save" class="btn-primary">Save</button>
        <button id="edit-commander-cancel" class="btn-secondary">Cancel</button>
      </div>
      <div id="edit-commander-result" style="margin-top:12px"></div>
    </div>
  </div>

  <script type="module">
    // CONFIG
    const USER_FIREBASE_CONFIG = {
      apiKey: "AIzaSyA_mz_fVsph8VHfCEG__9sWg_ZvwYX5_6E",
      authDomain: "mtg-life-tool.firebaseapp.com",
      projectId: "mtg-life-tool",
      storageBucket: "mtg-life-tool.appspot.com",
      messagingSenderId: "36730058988",
      appId: "1:36730058988:web:757e2d9620593b4f65022a"
    };
    const SCRYFALL_API = "https://api.scryfall.com/cards/named?exact=";
    const SCRYFALL_AUTOCOMPLETE_API = "https://api.scryfall.com/cards/autocomplete?q=";
    const ROOM_TIMEOUT_MINUTES = 20; // changed to 20 minutes
    const DELETE_ALL_PWD = "DeleteAllRooms";
    const AUTOCOMPLETE_DEBOUNCE_MS = 100;

    // IMPORTS
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, onSnapshot, serverTimestamp,
      arrayUnion, deleteDoc, collection, getDocs, query, limit, updateDoc
    } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // GLOBALS
    const app = initializeApp(USER_FIREBASE_CONFIG);
    const auth = getAuth(app);
    const db = getFirestore(app);

    let userId = null;
    let roomId = null;
    let unsubscribe = null;
    let autocompleteTimeout = null;
    const ROOM_COLLECTION = "mtg_rooms";
    const openCmdControls = new Set();

    function hashPassword(password){ return CryptoJS.SHA256(password).toString(CryptoJS.enc.Hex); }
    function getStartingLife(){ return 40; }

    async function validateCommander(name){
      if(!name) return null;
      try{
        const response = await fetch(`${SCRYFALL_API}${encodeURIComponent(name)}`);
        const data = await response.json();
        if(response.ok){
          const imageUrl = data.image_uris?.normal || data.card_faces?.[0]?.image_uris?.normal;
          if(imageUrl) return { validatedName: data.name, imageUrl };
        }
        return null;
      }catch(e){ console.error("Scryfall validation error:", e); return null; }
    }

    async function fetchAutocompleteSuggestions(query, listId, inputId){
      const suggestionsList = document.getElementById(listId);
      const inputField = document.getElementById(inputId);
      if(!suggestionsList || !inputField) return;
      suggestionsList.innerHTML = '';
      if(query.length < 2) return;
      try{
        const response = await fetch(`${SCRYFALL_AUTOCOMPLETE_API}${encodeURIComponent(query)}`);
        const data = await response.json();
        if(response.ok && data.data && data.data.length){
          data.data.slice(0,5).forEach(suggestion=>{
            const item = document.createElement('div');
            item.classList.add('suggestion-item');
            item.textContent = suggestion;
            item.onclick = () => { inputField.value = suggestion; suggestionsList.innerHTML = ''; };
            suggestionsList.appendChild(item);
          });
        }
      }catch(e){ console.error("Autocomplete error:", e); }
    }

    // compute outgoing map for a source player (what this player's commander has done to others)
    function computeOutgoingCmdDamage(roomData, sourcePlayerId){
      const players = roomData.players || {};
      const order = Array.isArray(roomData.playersOrder) && roomData.playersOrder.length ? roomData.playersOrder : Object.keys(players || {});
      const result = [];
      order.forEach(pid => {
        if(pid === sourcePlayerId) return;
        const dmg = (players[sourcePlayerId]?.commanderDamage || {})[pid] || 0;
        const name = players[pid]?.name || 'Player';
        result.push({ oppId: pid, oppName: name, dmg });
      });
      return result;
    }

    // compute outgoing total for a source player (sum of their commanderDamage map)
    function computeOutgoingTotal(roomData, sourcePlayerId){
      const dmgMap = (roomData.players?.[sourcePlayerId]?.commanderDamage) || {};
      return Object.keys(dmgMap).reduce((s,k)=> s + (parseInt(dmgMap[k])||0), 0);
    }

    // compute incoming total for a target player
    function computeIncomingCmdDamage(roomData, targetPlayerId){
      let total = 0;
      const players = roomData.players || {};
      Object.keys(players).forEach(pid=>{
        const dmgMap = players[pid]?.commanderDamage || {};
        const val = dmgMap[targetPlayerId] || 0;
        total += val;
      });
      return total;
    }

    // ROUTING
    const navButtons = { home: document.getElementById('nav-home'), changes: document.getElementById('nav-changes'), contact: document.getElementById('nav-contact') };
    function setActiveNav(page){ Object.values(navButtons).forEach(b=>b.classList.remove('active')); if(navButtons[page]) navButtons[page].classList.add('active'); }
    function navigateTo(page){ if(location.hash !== `#${page}`) history.pushState(null,'',`#${page}`); setActiveNav(page); if(page === 'home') renderHome(); else if(page === 'changes') renderChanges(); else if(page === 'contact') renderContact(); }
    navButtons.home.addEventListener('click', ()=>navigateTo('home'));
    navButtons.changes.addEventListener('click', ()=>navigateTo('changes'));
    navButtons.contact.addEventListener('click', ()=>navigateTo('contact'));
    window.addEventListener('popstate', ()=>{ const page = (location.hash || '#home').replace('#','') || 'home'; setActiveNav(page); if(page === 'home') renderHome(); else if(page === 'changes') renderChanges(); else if(page === 'contact') renderContact(); });

    async function renderHome(){ await renderSetupView(); }

    const CHANGELOG = [
      { version: "0.9.7", date: "2025-12-07", notes: "Show  to/from on each panel; incoming editor updates opponent's outgoing." },
      { version: "0.9.6", date: "2025-12-06", notes: "Stable player order and edit restrictions; UI polish." }
    ];

    function renderChanges(){
      const appContainer = document.getElementById('app-container');
      let html = `<h2 style="margin-top:0;color:var(--text)">Changes</h2><div style="display:flex;flex-direction:column;gap:12px">`;
      CHANGELOG.forEach(entry=>{
        html += `<div style="background:#121416;padding:12px;border-radius:8px;border:1px solid var(--dark-border)"><div style="display:flex;justify-content:space-between;align-items:center"><div style="font-weight:700;color:var(--text)">${entry.version}</div><div class="muted">${entry.date}</div></div><div style="margin-top:8px;color:var(--text)">${entry.notes}</div></div>`;
      });
      html += `</div>`;
      appContainer.innerHTML = html;
    }

    function renderContact(){
      const appContainer = document.getElementById('app-container');
      appContainer.innerHTML = `
        <h2 style="margin-top:0;color:var(--text)">Contact</h2>
        <p class="muted">To contact me, please use your email client. Click the button below to open a new message addressed to <strong>CardboardBonfire@gmail.com</strong>.</p>
        <div style="max-width:640px">
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="contact-mailto" class="btn-primary">Email CardboardBonfire@gmail.com</button>
            <button id="contact-copy" class="btn-secondary">Copy Email</button>
          </div>
          <p id="contact-status" class="muted" style="margin-top:8px"></p>
        </div>
      `;
      document.getElementById('contact-mailto').addEventListener('click', ()=>{
        const subject = encodeURIComponent("Contact from MTG Life Tracker");
        const body = encodeURIComponent("Hi,\n\nI'd like to get in touch regarding...");
        window.location.href = `mailto:CardboardBonfire@gmail.com?subject=${subject}&body=${body}`;
      });
      document.getElementById('contact-copy').addEventListener('click', async ()=>{
        const status = document.getElementById('contact-status');
        try{ await navigator.clipboard.writeText('CardboardBonfire@gmail.com'); status.textContent = 'Email address copied to clipboard.'; }
        catch(e){ console.error(e); status.textContent = 'Unable to copy automatically — please copy: CardboardBonfire@gmail.com'; }
      });
    }

    // SETUP VIEW
    async function renderSetupView(){
      const appContainer = document.getElementById("app-container");
      const statusMessage = document.getElementById("status-message");
      roomId = null;
      document.getElementById('lobby-card-preview').style.display = 'none';
      document.getElementById('card-search-modal').style.display = 'none';
      statusMessage.textContent = "Browse rooms or create a new one.";
      statusMessage.style.color = "#9aa3ad";

      let listHtml = '<p style="color:var(--text)">Loading active rooms...</p>';
      appContainer.innerHTML = `
        <div style="display:flex;gap:12px;align-items:center;margin-bottom:12px">
          <div style="flex:1"><input type="text" id="search-input" placeholder="Enter Room ID to Create/Search"></div>
          <div style="width:160px"><button id="search-btn" class="btn-primary" style="width:100%">Find or Create Room</button></div>
        </div>
        <h3 style="color:var(--text);margin-top:0">Active Rooms</h3>
        <div id="room-list-container">${listHtml}</div>
        <div style="margin-top:12px"><button id="delete-all-rooms-btn" class="btn-danger">Delete All Rooms (Admin)</button></div>
      `;

      try{
        const q = query(collection(db, ROOM_COLLECTION), limit(15));
        const snap = await getDocs(q);
        if(snap.empty) listHtml = '<p style="color:var(--text)">No active rooms. Create one above!</p>';
        else{
          listHtml = '';
          snap.forEach(docSnap=>{
            const rData = docSnap.data();
            const rId = docSnap.id;
            const pCount = Object.keys(rData.players || {}).length;
            const ownerPlayer = rData.players[rData.ownerId];
            const ownerCmdName = ownerPlayer?.commanderName || ownerPlayer?.commander || 'N/A';
            const ownerCmdImage = ownerPlayer?.commanderImageUrl || '';
            const ownerName = ownerPlayer?.name || 'Owner';

            // createdAt and lastLifeChange handling for display
            let createdAtText = 'Unknown';
            let timeLeftText = 'Unknown';
            try{
              const createdAt = rData.createdAt ? (rData.createdAt.toDate ? rData.createdAt.toDate() : new Date(rData.createdAt)) : null;
              const lastLife = rData.lastLifeChange ? (rData.lastLifeChange.toDate ? rData.lastLifeChange.toDate() : new Date(rData.lastLifeChange)) : createdAt;
              if(createdAt){
                createdAtText = createdAt.toLocaleString();
                const now = new Date();
                const elapsedMs = now - lastLife;
                const timeoutMs = ROOM_TIMEOUT_MINUTES * 60 * 1000;
                const remainingMs = Math.max(0, timeoutMs - elapsedMs);
                const mins = Math.floor(remainingMs / 60000);
                const secs = Math.floor((remainingMs % 60000) / 1000);
                timeLeftText = `${mins}m ${secs}s`;
              }
            }catch(e){ console.warn("Time parse error", e); }

            listHtml += `
              <div class="room-item" style="display:flex;justify-content:space-between;align-items:center;background-color:#121416;padding:12px;margin-bottom:8px;border-radius:8px;border:1px solid var(--dark-border)">
                <div class="room-info" style="min-width:0">
                  <div style="font-weight:800;color:var(--text);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:420px">${rId}</div>
                  <div style="font-size:.9em;color:var(--muted);margin-top:6px">
                    ${pCount} Player(s) • Owner: ${ownerName}
                    <span style="margin-left:8px;color:var(--muted)">[${ownerCmdName}]</span>
                    <div style="margin-top:6px;font-size:.85em;color:var(--muted)">Created: ${createdAtText} • Closes in: ${timeLeftText}</div>
                  </div>
                </div>
                <div style="display:flex;gap:8px;align-items:center">
                  <button class="show-cmd-btn btn-secondary" data-img-url="${ownerCmdImage}" title="Show CMD">Show CMD</button>
                  <button class="join-btn btn-secondary" data-rid="${rId}" style="width:auto">Join</button>
                </div>
              </div>
            `;
          });
        }
      }catch(e){
        console.error("List error:",e);
        listHtml = `<p style="color:#ff5555">Error loading rooms. Permissions might be initializing...</p>`;
      }

      const listContainer = document.getElementById("room-list-container");
      if(listContainer) listContainer.innerHTML = listHtml;

      if(listContainer){
        listContainer.querySelectorAll('.join-btn').forEach(btn=>{
          btn.addEventListener('click', (e)=> promptPassword(e.target.dataset.rid, 'join'));
        });

        // "Show CMD" hover behavior
        const previewCardEl = document.getElementById('lobby-card-preview');
        const previewImgEl = document.getElementById('preview-img');

        listContainer.querySelectorAll('.show-cmd-btn').forEach(btn=>{
          const imageUrl = btn.dataset.imgUrl;
          btn.addEventListener('mouseenter', ()=>{
            if(imageUrl && previewCardEl && previewImgEl){ previewImgEl.src = imageUrl; previewCardEl.style.display = 'block'; }
          });
          btn.addEventListener('mouseleave', ()=>{
            if(previewCardEl){ previewCardEl.style.display = 'none'; previewImgEl.src = ''; }
          });
          btn.addEventListener('click', ()=>{
            if(imageUrl && previewCardEl && previewImgEl){
              if(previewCardEl.style.display === 'block'){ previewCardEl.style.display = 'none'; previewImgEl.src = ''; }
              else { previewImgEl.src = imageUrl; previewCardEl.style.display = 'block'; }
            }
          });
        });
      }

      document.getElementById("search-btn").onclick = async ()=>{
        const val = document.getElementById("search-input").value.trim().toLowerCase();
        if(!val) return;
        const snap = await getDoc(doc(db, ROOM_COLLECTION, val));
        if(snap.exists()) promptPassword(val,'join'); else promptPassword(val,'create');
      };

      document.getElementById("delete-all-rooms-btn").addEventListener('click', deleteAllRooms);
    }

    // RENDER ROOM VIEW
    function renderChat(chatLog, playerName){
      const chatLogDiv = document.getElementById('chat-log');
      if(!chatLogDiv) return;
      chatLogDiv.innerHTML = '';
      const displayLog = (chatLog || []).slice(-200);
      displayLog.forEach(msg=>{
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('chat-message');
        const senderSpan = document.createElement('span');
        senderSpan.classList.add('chat-sender');
        if(msg.senderName === 'System'){ senderSpan.classList.add('system'); senderSpan.textContent = 'System:'; }
        else senderSpan.textContent = `${msg.senderName}:`;
        messageDiv.appendChild(senderSpan);
        if(msg.cardImageUrl){
          const cardSpan = document.createElement('span');
          cardSpan.classList.add('chat-card');
          cardSpan.textContent = ` ${msg.message} `;
          cardSpan.dataset.cardImageUrl = msg.cardImageUrl;
          cardSpan.dataset.cardName = msg.message;
          messageDiv.appendChild(cardSpan);
          cardSpan.addEventListener('mouseenter', (e)=>{ showChatCardPreview(cardSpan.dataset.cardImageUrl, cardSpan.dataset.cardName); });
          cardSpan.addEventListener('mouseleave', (e)=>{ hideChatCardPreviewWithDelay(); });
          cardSpan.addEventListener('click', (e)=>{ const preview = document.getElementById('chat-card-preview'); if(preview.style.display === 'block') hideChatCardPreviewImmediate(); else showChatCardPreview(cardSpan.dataset.cardImageUrl, cardSpan.dataset.cardName); });
        } else {
          messageDiv.appendChild(document.createTextNode(' ' + msg.message));
        }
        chatLogDiv.appendChild(messageDiv);
      });
      chatLogDiv.scrollTop = chatLogDiv.scrollHeight;
    }

    let chatPreviewHideTimer = null;
    function showChatCardPreview(imageUrl, title){
      if(chatPreviewHideTimer){ clearTimeout(chatPreviewHideTimer); chatPreviewHideTimer = null; }
      const preview = document.getElementById('chat-card-preview');
      const img = document.getElementById('chat-preview-img');
      const t = document.getElementById('chat-preview-title');
      img.src = imageUrl; t.textContent = title; preview.style.display = 'block';
    }
    function hideChatCardPreviewWithDelay(){ if(chatPreviewHideTimer) clearTimeout(chatPreviewHideTimer); chatPreviewHideTimer = setTimeout(()=>{ hideChatCardPreviewImmediate(); }, 300); }
    function hideChatCardPreviewImmediate(){ const preview = document.getElementById('chat-card-preview'); const img = document.getElementById('chat-preview-img'); const t = document.getElementById('chat-preview-title'); preview.style.display = 'none'; img.src = ''; t.textContent = ''; if(chatPreviewHideTimer){ clearTimeout(chatPreviewHideTimer); chatPreviewHideTimer = null; } }

    // Helper: subscribe to a room and handle timeout logic
    async function subscribeToRoom(rId){
      if(unsubscribe) { unsubscribe(); unsubscribe = null; }
      roomId = rId;
      localStorage.setItem('mtg_last_room', roomId);
      const roomRef = doc(db, ROOM_COLLECTION, roomId);
      unsubscribe = onSnapshot(roomRef, async (snap) => {
        if(!snap.exists()){
          // room deleted
          alert('Room has been closed or deleted.');
          localStorage.removeItem('mtg_last_room');
          roomId = null;
          if(unsubscribe){ unsubscribe(); unsubscribe = null; }
          renderSetupView();
          return;
        }
        const roomData = snap.data();

        // Determine last activity time (life changes)
        const lastLife = roomData.lastLifeChange ? (roomData.lastLifeChange.toDate ? roomData.lastLifeChange.toDate() : new Date(roomData.lastLifeChange)) : (roomData.createdAt ? (roomData.createdAt.toDate ? roomData.createdAt.toDate() : new Date(roomData.createdAt)) : new Date());
        const now = new Date();
        const elapsedMs = now - lastLife;
        const timeoutMs = ROOM_TIMEOUT_MINUTES * 60 * 1000;

        if(elapsedMs >= timeoutMs){
          // close/delete room automatically
          try{
            await deleteDoc(roomRef);
            localStorage.removeItem('mtg_last_room');
            if(unsubscribe){ unsubscribe(); unsubscribe = null; }
            alert(`Room ${roomId} closed due to inactivity.`);
            roomId = null;
            renderSetupView();
            return;
          }catch(e){ console.error("Error deleting timed-out room:", e); }
        } else {
          // schedule a deletion when timeout occurs
          const remainingMs = timeoutMs - elapsedMs;
          if(window._roomTimeoutHandle) { clearTimeout(window._roomTimeoutHandle); window._roomTimeoutHandle = null; }
          window._roomTimeoutHandle = setTimeout(async ()=>{
            try{ await deleteDoc(roomRef); localStorage.removeItem('mtg_last_room'); if(unsubscribe){ unsubscribe(); unsubscribe = null; } alert(`Room ${roomId} closed due to inactivity.`); roomId = null; renderSetupView(); } catch(e){ console.error("Auto-delete error:", e); }
          }, remainingMs + 500); // small buffer
        }

        // render the room UI
        renderRoomView(roomData);
      }, (err) => {
        console.error("Room snapshot error:", err);
      });
    }

    // Attempt to rejoin a room without password if the user is already a player in that room
    async function tryRestoreLastRoom(){
      const last = localStorage.getItem('mtg_last_room');
      if(!last) return;
      try{
        const snap = await getDoc(doc(db, ROOM_COLLECTION, last));
        if(!snap.exists()) { localStorage.removeItem('mtg_last_room'); return; }
        const data = snap.data();
        if(data.players && data.players[userId]){
          // user is already in the room; subscribe directly
          await subscribeToRoom(last);
        } else {
          // not a member; do nothing (user must join)
          localStorage.removeItem('mtg_last_room');
        }
      }catch(e){ console.error("Restore room error:", e); }
    }

    // Update lastLifeChange timestamp when life or commander damage changes
    async function updateLifeChangeTimestamp(){
      if(!roomId) return;
      try{
        const roomRef = doc(db, ROOM_COLLECTION, roomId);
        await updateDoc(roomRef, { lastLifeChange: serverTimestamp() });
      }catch(e){ console.error("Failed to update lastLifeChange:", e); }
    }

    // Global event delegation to detect life/commander changes and update timestamp
    document.addEventListener('click', async (e) => {
      const el = e.target;
      if(!el) return;
      // Buttons that change life or commander damage typically have data-action attributes
      const action = el.dataset?.action;
      if(action && ['infect-add','infect-sub','cmd-target-add','cmd-target-sub','cmd-target-set','life-add','life-sub'].includes(action)){
        // call update timestamp after a short delay to allow the underlying handlers to update Firestore
        setTimeout(()=> updateLifeChangeTimestamp(), 250);
      }
      // Join/Leave handlers are elsewhere; ensure leaving clears localStorage
      if(el.id === 'leave-room-btn'){
        localStorage.removeItem('mtg_last_room');
      }
    });

    // Also watch for numeric input changes for commander damage fields
    document.addEventListener('change', (e) => {
      const el = e.target;
      if(!el) return;
      if(el.classList && el.classList.contains('cmd-target-input')){
        // user edited a commander damage input directly
        setTimeout(()=> updateLifeChangeTimestamp(), 250);
      }
    });

    // When rendering a room view, persist the room id so refresh keeps the user in the lobby
    function renderRoomView(roomData){
      const appContainer = document.getElementById("app-container");
      const statusMessage = document.getElementById("status-message");
      document.getElementById('lobby-card-preview').style.display = 'none';
      document.getElementById('card-search-modal').style.display = 'none';
      const currentPlayerName = roomData.players[userId]?.name || 'You';
      statusMessage.innerHTML = `Connected as: <strong>${currentPlayerName}</strong>`;

      // persist last room so refresh restores
      if(roomId) localStorage.setItem('mtg_last_room', roomId);

      let html = `
        <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:12px">
          <div>
            <h2 style="margin:0;color:var(--text)">Room: ${roomId}</h2>
            <div style="color:var(--muted);font-size:.9rem;margin-top:6px">Players: ${Object.keys(roomData.players).length}</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center">
            <button id="card-search-btn" class="btn-secondary">Card Search</button>
            <button id="restart-game-btn" class="btn-secondary">Restart Game</button>
            <button id="share-invite-btn" class="btn-secondary">Share Invite</button>
            <button id="leave-room-btn" class="btn-danger">Leave Room</button>
          </div>
        </div>
      `;

      const playerIds = Array.isArray(roomData.playersOrder) && roomData.playersOrder.length ? [...roomData.playersOrder] : Object.keys(roomData.players || {});
      if (playerIds.includes(userId)) { const idx = playerIds.indexOf(userId); if (idx > 0) { playerIds.splice(idx, 1); playerIds.unshift(userId); } }
      else if (roomData.players && roomData.players[userId]) playerIds.unshift(userId);

      html += `<div class="player-grid">`;
      playerIds.forEach(playerId=>{
        const player = roomData.players[playerId];
        if(!player) return;
        const isMe = playerId === userId;
        const life = player.life ?? getStartingLife();
        const commanderName = player.commanderName || player.commander || 'N/A';
        const infectVal = player.infect || 0;

        // Build per-opponent rows: show the damage that each opponent has dealt to this player.
        // Value comes from players[oppId].commanderDamage[playerId]
        let perOppRows = '';
        const opponents = playerIds.filter(id => id !== playerId);
        if(opponents.length > 0){
          opponents.forEach(oppId => {
            const dmg = (roomData.players[oppId]?.commanderDamage || {})[playerId] || 0;
            const oppName = roomData.players[oppId]?.name || 'Player';
            const editable = (playerId === userId);
            const disabledAttr = editable ? '' : 'disabled';
            perOppRows += `
              <div class="per-opp-row" data-target="${playerId}" data-opp="${oppId}">
                <div class="per-opp-left">From <strong>${oppName}</strong></div>
                <div class="per-opp-controls">
                  <button class="control-btn negative small-btn" data-action="cmd-target-sub" data-target="${playerId}" data-opp="${oppId}" ${disabledAttr}>-</button>
                  <input type="number" value="${dmg}" data-target="${playerId}" data-opp="${oppId}" class="cmd-target-input" style="width:64px;padding:6px;border-radius:6px;border:1px solid var(--dark-border);background:var(--input-bg);color:var(--text);text-align:center" ${disabledAttr}>
                  <button class="control-btn negative small-btn" data-action="cmd-target-add" data-target="${playerId}" data-opp="${oppId}" ${disabledAttr}>+</button>
                </div>
              </div>
            `;
          });
        }

        // Infect controls (only editable for your own player)
        const infectControlsHtml = `
          <div style="display:flex;align-items:center;gap:6px">
            <button class="control-btn small-btn" data-action="infect-sub" data-player="${playerId}" ${isMe ? '' : 'disabled'}>-</button>
            <div class="infect-value" id="infect-${playerId}">${infectVal}</div>
            <button class="control-btn small-btn" data-action="infect-add" data-player="${playerId}" ${isMe ? '' : 'disabled'}>+</button>
          </div>
        `;

        html += `
          <div class="player-panel" id="panel-${playerId}">
            <div class="player-header">
              <div>
                <div class="player-name">${player.name || 'Player'}</div>
                <div class="player-sub">${commanderName}</div>
              </div>
              <div style="text-align:right">
                <div class="life-big" id="life-${playerId}">${life}</div>
                <div style="margin-top:6px">${isMe ? '<span class="you-badge">YOU</span>' : ''}</div>
              </div>
            </div>

            <div class="cmd-block">
              <div>
                <div class="cmd-label">Commander Damage To Others</div>
                <div class="cmd-value">${computeOutgoingTotal(roomData, playerId)}</div>
              </div>
              <div>
                <div class="cmd-label">Commander Damage From Others</div>
                <div class="cmd-value">${computeIncomingCmdDamage(roomData, playerId)}</div>
              </div>
            </div>

            <div class="per-opp-container">
              ${perOppRows}
            </div>

            <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
              <div>${infectControlsHtml}</div>
              <div style="display:flex;gap:8px">
                <button class="control-btn small-btn" data-action="life-sub" data-player="${playerId}" ${isMe ? '' : 'disabled'}>-</button>
                <button class="control-btn small-btn" data-action="life-add" data-player="${playerId}" ${isMe ? '' : 'disabled'}>+</button>
                <button class="control-btn small-btn" data-action="edit-commander" data-player="${playerId}">Edit CMD</button>
              </div>
            </div>
          </div>
        `;
      });
      html += `</div>`;

      // Chat and footer
      html += `
        <div id="room-footer">
          <div class="muted">Room ID: ${roomId}</div>
          <div class="muted">Created: ${roomData.createdAt ? (roomData.createdAt.toDate ? roomData.createdAt.toDate().toLocaleString() : new Date(roomData.createdAt).toLocaleString()) : 'Unknown'}</div>
          <div class="muted">Timeout: ${ROOM_TIMEOUT_MINUTES} minutes of inactivity</div>
        </div>
      `;

      appContainer.innerHTML = html;

      // Wire up buttons that exist in this snippet (some handlers may be defined elsewhere)
      document.getElementById('card-search-btn')?.addEventListener('click', ()=>{ document.getElementById('card-search-modal').style.display = 'flex'; });
      document.getElementById('leave-room-btn')?.addEventListener('click', async ()=>{
        try{
          // remove local storage marker and navigate back to lobby
          localStorage.removeItem('mtg_last_room');
          if(unsubscribe){ unsubscribe(); unsubscribe = null; }
          roomId = null;
          renderSetupView();
        }catch(e){ console.error(e); }
      });

      // Attach per-panel control handlers (simple local handlers; actual firestore updates may be elsewhere)
      // Use event delegation for the player grid
      const grid = document.querySelector('.player-grid');
      if(grid){
        grid.addEventListener('click', async (ev)=>{
          const btn = ev.target.closest('button');
          if(!btn) return;
          const action = btn.dataset.action;
          if(!action) return;
          // Basic handlers: update Firestore player fields accordingly
          try{
            const roomRef = doc(db, ROOM_COLLECTION, roomId);
            if(action === 'life-add' || action === 'life-sub'){
              const pid = btn.dataset.player;
              const delta = action === 'life-add' ? 1 : -1;
              const current = (roomData.players?.[pid]?.life) ?? getStartingLife();
              const newVal = current + delta;
              await updateDoc(roomRef, { [`players.${pid}.life`]: newVal, lastLifeChange: serverTimestamp() });
            } else if(action === 'infect-add' || action === 'infect-sub'){
              const pid = btn.dataset.player;
              const delta = action === 'infect-add' ? 1 : -1;
              const current = (roomData.players?.[pid]?.infect) ?? 0;
              const newVal = Math.max(0, current + delta);
              await updateDoc(roomRef, { [`players.${pid}.infect`]: newVal, lastLifeChange: serverTimestamp() });
            } else if(action === 'cmd-target-add' || action === 'cmd-target-sub'){
              const target = btn.dataset.target;
              const opp = btn.dataset.opp;
              const delta = action === 'cmd-target-add' ? 1 : -1;
              const current = (roomData.players?.[opp]?.commanderDamage?.[target]) || 0;
              const newVal = Math.max(0, current + delta);
              await updateDoc(roomRef, { [`players.${opp}.commanderDamage.${target}`]: newVal, lastLifeChange: serverTimestamp() });
            } else if(action === 'edit-commander'){
              // open edit modal (existing modal element)
              const pid = btn.dataset.player;
              const modal = document.getElementById('edit-commander-modal');
              const input = document.getElementById('edit-commander-name');
              input.value = roomData.players?.[pid]?.commanderName || roomData.players?.[pid]?.commander || '';
              modal.style.display = 'flex';
              // save handler will update the player's commander (handler defined elsewhere)
              document.getElementById('edit-commander-save').onclick = async ()=>{
                const newName = input.value.trim();
                if(!newName) return;
                const validated = await validateCommander(newName);
                const updates = {};
                updates[`players.${pid}.commanderName`] = validated?.validatedName || newName;
                if(validated?.imageUrl) updates[`players.${pid}.commanderImageUrl`] = validated.imageUrl;
                updates.lastLifeChange = serverTimestamp();
                await updateDoc(roomRef, updates);
                modal.style.display = 'none';
              };
              document.getElementById('edit-commander-cancel').onclick = ()=>{ document.getElementById('edit-commander-modal').style.display = 'none'; };
            }
          }catch(err){ console.error("Control action error:", err); }
        });
      }
    }

    // Initialization: sign in anonymously and try to restore last room
    (async function init(){
      try{
        const user = await signInAnonymously(auth);
        // signInAnonymously returns a promise but onAuthStateChanged will set userId; ensure we capture it
      }catch(e){ console.warn("Anonymous sign-in may be pending or blocked:", e); }

      onAuthStateChanged(auth, async (u) => {
        if(u){
          userId = u.uid;
          // After auth, try to restore last room if any
          await tryRestoreLastRoom();
          // If no room restored, render home
          const last = localStorage.getItem('mtg_last_room');
          if(!last) renderHome();
        } else {
          userId = null;
          renderHome();
        }
      });

      // initial route
      const page = (location.hash || '#home').replace('#','') || 'home';
      setActiveNav(page);
      if(page === 'home') renderHome(); else if(page === 'changes') renderChanges(); else if(page === 'contact') renderContact();
    })();

    // Placeholder: promptPassword, deleteAllRooms, and other functions referenced above should exist in the full codebase.
    // Minimal implementations to avoid runtime errors in this snippet:
    async function promptPassword(rid, mode){
      // If the user is already a member, join without password
      try{
        const snap = await getDoc(doc(db, ROOM_COLLECTION, rid));
        if(snap.exists()){
          const data = snap.data();
          if(data.players && data.players[userId]){
            await subscribeToRoom(rid);
            return;
          }
        }
      }catch(e){ console.error(e); }
      // Fallback: open a simple prompt for password or create
      if(mode === 'create'){
        const create = confirm(`Create room "${rid}"?`);
        if(!create) return;
        try{
          const roomRef = doc(db, ROOM_COLLECTION, rid);
          const now = serverTimestamp();
          const initial = {
            createdAt: now,
            lastLifeChange: now,
            ownerId: userId,
            players: {
              [userId]: { name: 'You', life: getStartingLife(), commanderName: '', commanderImageUrl: '' }
            },
            playersOrder: [userId]
          };
          await setDoc(roomRef, initial);
          await subscribeToRoom(rid);
        }catch(e){ console.error("Create room error:", e); alert("Failed to create room."); }
      } else {
        // join existing room: add player entry (no password flow)
        try{
          const roomRef = doc(db, ROOM_COLLECTION, rid);
          const snap = await getDoc(roomRef);
          if(!snap.exists()){ alert("Room not found."); return; }
          const data = snap.data();
          // add player if not present
          if(!data.players || !data.players[userId]){
            const updates = {};
            updates[`players.${userId}`] = { name: 'You', life: getStartingLife(), commanderName: '', commanderImageUrl: '' };
            // ensure playersOrder exists
            const newOrder = Array.isArray(data.playersOrder) ? [...data.playersOrder] : Object.keys(data.players || {});
            if(!newOrder.includes(userId)) newOrder.push(userId);
            await updateDoc(roomRef, { ...updates, playersOrder: newOrder, lastLifeChange: serverTimestamp() });
          }
          await subscribeToRoom(rid);
        }catch(e){ console.error("Join room error:", e); alert("Failed to join room."); }
      }
    }

    async function deleteAllRooms(){
      const pwd = prompt("Enter admin password to delete all rooms:");
      if(pwd !== DELETE_ALL_PWD) { alert("Incorrect password."); return; }
      try{
        const snap = await getDocs(query(collection(db, ROOM_COLLECTION), limit(100)));
        const deletes = [];
        snap.forEach(s => deletes.push(deleteDoc(doc(db, ROOM_COLLECTION, s.id))));
        await Promise.all(deletes);
        alert("Deleted up to 100 rooms.");
        renderSetupView();
      }catch(e){ console.error(e); alert("Failed to delete rooms."); }
    }

  </script>
</body>
</html>
